package com.csc.fsg.nba.business.process.evaluation;

/*
 * **************************************************************************<BR>
 * This program contains trade secrets and confidential information which<BR>
 * are proprietary to CSC Financial Services Group®.  The use,<BR>
 * reproduction, distribution or disclosure of this program, in whole or in<BR>
 * part, without the express written permission of CSC Financial Services<BR>
 * Group is prohibited.  This program is also an unpublished work protected<BR>
 * under the copyright laws of the United States of America and other<BR>
 * countries.  If this program becomes published, the following notice shall<BR>
 * apply:
 *     Property of Computer Sciences Corporation.<BR>
 *     Confidential. Not for publication.<BR>
 *     Copyright (c) 2002-2008 Computer Sciences Corporation. All Rights Reserved.<BR>
 * **************************************************************************<BR>
 */

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.csc.dip.jvpms.runtime.base.VpmsComputeResult;
import com.csc.fsg.nba.datamanipulation.NbaOinkDataAccess;
import com.csc.fsg.nba.datamanipulation.NbaOinkRequest;
import com.csc.fsg.nba.exception.NbaBaseException;
import com.csc.fsg.nba.exception.NbaVpmsException;
import com.csc.fsg.nba.foundation.NbaConstants;
import com.csc.fsg.nba.foundation.NbaOLifEId;
import com.csc.fsg.nba.foundation.NbaOliConstants;
import com.csc.fsg.nba.foundation.NbaUtils;
import com.csc.fsg.nba.vo.NbaAcdb;
import com.csc.fsg.nba.vo.NbaTXLife;
import com.csc.fsg.nba.vo.txlife.Attachment;
import com.csc.fsg.nba.vo.txlife.Coverage;
import com.csc.fsg.nba.vo.txlife.CriteriaInfo;
import com.csc.fsg.nba.vo.txlife.FamilyIllness;
import com.csc.fsg.nba.vo.txlife.FamilyIllnessExtension;
import com.csc.fsg.nba.vo.txlife.ImpairmentInfo;
import com.csc.fsg.nba.vo.txlife.OLifE;
import com.csc.fsg.nba.vo.txlife.OLifEExtension;
import com.csc.fsg.nba.vo.txlife.Party;
import com.csc.fsg.nba.vo.txlife.PartyExtension;
import com.csc.fsg.nba.vo.txlife.PreferredInfo;
import com.csc.fsg.nba.vo.txlife.RequirementInfo;
import com.csc.fsg.nba.vo.txlife.Risk;
import com.csc.fsg.nba.vo.txlife.UnderwritingAnalysis;
import com.csc.fsg.nba.vpms.NbaVpmsAdaptor;
import com.csc.fsg.nba.vpms.NbaVpmsConstants;
import com.csc.fsg.nba.vpms.NbaVpmsModelResult;
import com.csc.fsg.nba.vpms.NbaVpmsResultsData;
import com.csc.fsg.nba.vpms.results.VpmsModelResult;


/**
 * Class that will take care of the processing once ACLabPulse model is invoked 
 * from NBCTEVAL and NBRQEVAL process.
 * <p>Implements NbaVpmsModelProcessor 
 * <p>
 * <b>Modifications:</b><br>
 * <table border=0 cellspacing=5 cellpadding=5>
 * <thead>
 *   <th align=left>Project</th><th align=left>Release</th><th align=left>Description</th>
 * </thead>
 * <tr><td>ACP008</td><td>Version 4</td><td>Preferred Processing</td></tr>
 * <tr><td>SPR2652</td><td>Version 5</td><td>APCTEVAL process getting error stopped with Run time error occured message</td><tr>
 * <tr><td>SPR2639</td><td>Version 5</td><td>Automated process status should be based business function</td></tr>
 * <tr><td>SPR3329</td><td>Version 7</td><td>Prevent erroneous "Retrieve variable name is invalid" messages from being generated by OINK</td></tr>
 * <tr><td>SPR3362</td><td>Version 7</td><td>Exceptions in Automated Processes and Logon Service Due to VP/MS Memory Leak</td></tr>
 * <tr><td>SPR3290</td><td>Version 7</td><td>General source code clean up during version 7</td></tr>
 * <tr><td>SPR3353</td><td>Version 8</td><td>OINK problem handling multiple requirements in the same XML</td></tr>
 * <tr><td>AXAL3.7.08</td><td>AXA Life Phase 1</td><td>Preferred Processing</td></tr>
 * <tr><td>ALS4576</td><td>AXA Life Phase 1</td><td>QC # 3647 - 3.7.31 provider feed from CRL, lab results not displayed on preferred profile</td></tr>
 * <tr><td>CR731686</td><td>AXA Life Phase 2</td><td>Preferred Processing</td></tr>
 * </table>
 * <p>
 * @author CSC FSG Developer
 * @version 7.0.0
 * @since New Business Accelerator - Version 4
 */

public class NbaACPrfCriteriaProcessor extends NbaVpmsModelProcessor {	
	//Impairments generated by this class will be stored in this instance. 
	//Such an instance will be in each class that invokes the model.
	protected ArrayList criteriaImpairments = new ArrayList();//ACN024
	protected ArrayList criteriaAccepImpairments = null;
	// Input CriteriaInfo List is read once from Contract (nbaTxLife object)
	// and input to VPMS model for all preferred levels.
	protected ArrayList criteriaInfoListIn = new ArrayList();
	// Output CriteriaInfo List is read from VPMS model output
	// CriteriaInfoList from all levels are added to nbaTxLife object and
	// evenutally to Database.
	protected ArrayList criteriaInfoListOut = new ArrayList();
	protected PreferredInfo preferredInfo = null;
	int numberOfLevels = 0; // number of Preferred levels for an insured.	

	/**
	 * Overridden method, calls the model and 
	 * updates the contract with impairments.
	 * @throws NbaBaseException
	 */
	public void execute() throws NbaBaseException {
		boolean isSuccess = false;

		impSrc = NbaConstants.PREFERRED_SRC; //ACN016
		
		if (performingContractEvaluation()) { //SPR2652
			int partyIndex = 0;
			ArrayList al = getAllInsuredIndexes();
			OLifE oLifE = nbaTxLife.getOLifE();
			int insListCount = al.size();
			// SPR3290 code deleted
			String partyId = "";
			for(int i=0;i<insListCount;i++){
				partyIndex = ((Integer)al.get(i)).intValue();
				partyId = oLifE.getPartyAt(partyIndex).getId();
				partyID = partyId;
				// SPR3290 code deleted						
				criteriaImpairments.clear();	  //ACN024						
				
				// get Input CriteriaInfo List
				preferredInfo = nbaTxLife.getPreferredInfo(partyID);
				criteriaInfoListIn = new ArrayList();
				if (preferredInfo != null) {
					criteriaInfoListIn = preferredInfo.getCriteriaInfo();
				}
				// clear Output CriteriaInfo List
				criteriaInfoListOut = new ArrayList();
				// first get the number of Preferred Levels
				numberOfLevels = getNumberOfLevels(nbaTxLife); //SPR3353
				for(int j=1; j<=numberOfLevels; j++) {
					isSuccess = callPrfCriteriaModel(i, j); // overwrites the CriteriaInfoList
					if (!isSuccess){
						throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + NbaVpmsAdaptor.ACPRFCRITERIA);	//SPR2652 
					}
				}
				if (numberOfLevels > 0) {
					isSuccess = callPrfCriteriaModel(i, 0);
					if (!isSuccess){
						throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + NbaVpmsAdaptor.ACPRFCRITERIA);	//SPR2652 
					}
					ArrayList prefInfoList = new ArrayList();
					prefInfoList.add(preferredInfo);
					updatePreferredInfoList(partyID, prefInfoList);
					getContractImpairments(partyId);
					ArrayList[] mergedLists = mergeImpairments(contractImpairments, criteriaImpairments, new ArrayList(), new ArrayList());
					ArrayList arrMerged = mergedLists[0];
					addImpairmentInfo(partyId, arrMerged);					
				}
			}
		}
		else if (performingRequirementsEvaluation()) { //SPR2652
			setPartyID(work); //ACN024
			
			//	get Input CriteriaInfo List
			preferredInfo = nbaTxLife.getPreferredInfo(partyID);
			criteriaInfoListIn = new ArrayList();
			if (preferredInfo != null) {
				criteriaInfoListIn = preferredInfo.getCriteriaInfo();
			}
			// first get the number of Preferred Levels
			numberOfLevels = getNumberOfLevels(txLifeReqResult); //SPR3353
			for(int j=1; j<=numberOfLevels; j++) {
				isSuccess = callPrfCriteriaModelForReqEval(j); // overwrites the CriteriaInfoList
				if (!isSuccess){
					throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + NbaVpmsAdaptor.ACPRFCRITERIA);	//SPR2652 
				}
			}
			if (numberOfLevels > 0) {
				isSuccess = callPrfCriteriaModelForReqEval(0);
				if (!isSuccess){
					throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + NbaVpmsAdaptor.ACPRFCRITERIA);	//SPR2652 
				}
				ArrayList prefInfoList = new ArrayList();
				prefInfoList.add(preferredInfo);
				updatePreferredInfoList(partyID, prefInfoList);
				//Do the Impairments Merging //ACN024
				mergeImpairmentsAndAccep(criteriaImpairments,criteriaAccepImpairments); //ACN016				
			}
		}
	}
	
	/**
	 * This function acts as an entry point for calling the ACPrfCriteria model
	 * @param source The source used for OinkDataAccess
	 * @return int : Returns Number of Preferred Levels
	 * @throws NbaBaseException
	 */
	//SPR3353 method signature changed. Add NbaTXLife as param
	public int getNumberOfLevels(NbaTXLife source) throws NbaBaseException {
		int prfLevel = 0;
		NbaVpmsAdaptor vpmsProxy = null; //SPR3362
		try {			
			HashMap deOinkMap = new HashMap();
			NbaOinkDataAccess accessContract = new NbaOinkDataAccess();
			accessContract.setAcdbSource(new NbaAcdb(), nbaTxLife);
			accessContract.setLobSource(work.getNbaLob());
			accessContract.setContractSource(source);//SPR3329, SPR3353
			accessContract.setPlanSource(nbaTxLife, null);//CR731686
			deOinkProductCode(deOinkMap);
			vpmsProxy = new NbaVpmsAdaptor(accessContract, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR3362
			vpmsProxy.setVpmsEntryPoint(NbaVpmsAdaptor.EP_NO_OF_PRF_LEVELS);
			vpmsProxy.setSkipAttributesMap(deOinkMap);
			//begin SPR3353
			NbaOinkRequest oinkRequest = new NbaOinkRequest();
            oinkRequest.setRequirementIdFilter(reqId);
            oinkRequest.setArgs(getKeys());

            vpmsProxy.setANbaOinkRequest(oinkRequest);
			//end SPR3353
			String numberOfLevels =vpmsProxy.getResults().getResult();
			try{
				prfLevel = Integer.parseInt(numberOfLevels);
			}catch(NumberFormatException e){
				prfLevel = 0;
			}		
			//SPR3362 code deleted				
		} catch (RemoteException re) {
			handleRemoteException(re, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR2652
		// SPR2652 Code Deleted
		//begin SPR3362
		} finally {
		    if(vpmsProxy != null){
		        try {
                    vpmsProxy.remove();
                } catch (RemoteException e) {
                    getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
                }
		    }
		//end SPR3362
		}
		return prfLevel;		
	}	

	/**
	 * This function acts as an entry point for calling the ACPrfCriteria model from RequirementEvaluation automated process.
	 * @param level: current level of processing
	 * @return boolean : Returns true if the call is successful
	 * 					 Else returns false 	
	 * @throws NbaBaseException
	 */
	public boolean callPrfCriteriaModelForReqEval(int level) throws NbaBaseException {
		HashMap deOinkMap = new HashMap();		
		boolean success = true;
		ArrayList results = null;
		NbaOinkRequest oinkRequest = new NbaOinkRequest();//CR731686
		if (updatePartyFilterInRequest(oinkRequest, partyID)) {//CR731686
			NbaOinkDataAccess oinkData = new NbaOinkDataAccess(txLifeReqResult);
			oinkData.setAcdbSource(new NbaAcdb(), nbaTxLife);
			oinkData.setLobSource(work.getNbaLob());
			oinkData.setPlanSource(nbaTxLife, null);//CR731686
			//SPR3353 code deleted
			NbaVpmsAdaptor vpmsProxy = null; //SPR3362
			try { //SPR3362
				vpmsProxy = new NbaVpmsAdaptor(oinkData, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR3362
				vpmsProxy.setVpmsEntryPoint(NbaVpmsAdaptor.EP_RESULTXML);

				// deOink general fields
				deOinkMap.put(NbaVpmsConstants.A_PROCESS_ID, NbaUtils.getBusinessProcessId(getUser())); //SPR2639
				deOinkMap.put("A_Run_Level", String.valueOf(level));

				// call deOink methods
				deOinkImpairmentFields(deOinkMap);
				deOinkProductCode(deOinkMap);
				deOinkFamillyIllnessValues(deOinkMap);
				deOinkPreferredDetailInputs(deOinkMap, level);
				getLabTestDeOINKValues(deOinkMap);
			    //getRxScoreOINKValues(deOinkMap); // APSL4278 , Code commented for APSL4427
				//CR731686 code moved up
				oinkRequest.setRequirementIdFilter(reqId);
				oinkRequest.setArgs(getKeys());
				vpmsProxy.setANbaOinkRequest(oinkRequest);
				vpmsProxy.setSkipAttributesMap(deOinkMap);
				VpmsComputeResult vcr;
				try {
					vcr = vpmsProxy.getResults();
					NbaVpmsResultsData vpmsResultsData = new NbaVpmsResultsData(vcr);
					results = vpmsResultsData.getResultsData();
					//Resulting string will be the zeroth element.
					if (results == null) {
						//SPR3362 code deleted
						throw new NbaVpmsException(NbaVpmsException.VPMS_NO_RESULTS + NbaVpmsAdaptor.ACPRFCRITERIA); //SPR2652
					} //SPR2652
					vpmsResult = (String) results.get(0);
					NbaVpmsModelResult vpmsOutput = new NbaVpmsModelResult(vpmsResult);
					VpmsModelResult vpmModelResult = vpmsOutput.getVpmsModelResult();
					criteriaImpairments = vpmModelResult.getImpairmentInfo(); //ACN024
					ArrayList prefInfoList = vpmModelResult.getPreferredInfo();
					if (prefInfoList != null && prefInfoList.size() != 0) {
						preferredInfo = vpmModelResult.getPreferredInfoAt(0);
						// add to criteriaInfoList, but not for level 0
						if (level > 0) {
							ArrayList tempCriteriaList = preferredInfo.getCriteriaInfo();
							if (tempCriteriaList != null && tempCriteriaList.size() > 0) {
								criteriaInfoListOut.addAll(preferredInfo.getCriteriaInfo());
							}
						}
					}
					success = true;
					// SPR2652 Code Deleted
					//SPR3362 code deleted
				} catch (RemoteException re) {
					handleRemoteException(re, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR2652
					// SPR2652 Code Deleted
				}
				//begin SPR3362
			} finally {
				if (vpmsProxy != null) {
					try {
						vpmsProxy.remove();
					} catch (RemoteException e) {
						getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
					}
				}
				//end SPR3362
			}
		}
		return success;
	}

	/**
	 * This function acts as an entry point for calling the ACPrfCriteria model from ContractEvaluation automated process.
	 * 
	 * @param insuredIndex:
	 *            Index of the insured
	 * @param level:
	 *            current level of processing
	 * @return boolean : Returns true if the call is successful Else returns false
	 * @throws NbaBaseException
	 */
	public boolean callPrfCriteriaModel(int insuredIndex, int level) throws NbaBaseException {
		HashMap deOinkMap = new HashMap();	
		boolean success = false;	//SPR2652
		NbaOinkRequest oinkRequest = new NbaOinkRequest();	//SPR2652
		if (updatePartyFilterInRequest(oinkRequest, partyID)) { //SPR2652	
			ArrayList results = null;
			NbaOinkDataAccess oinkData = new NbaOinkDataAccess(nbaTxLife);
			oinkData.setAcdbSource(new NbaAcdb(), nbaTxLife);
			oinkData.setLobSource(work.getNbaLob());
			oinkData.setContractSource(nbaTxLife);//SPR3329
			oinkData.setPlanSource(nbaTxLife, null);//CR731686
			NbaVpmsAdaptor vpmsProxy = null; //SPR3362
            try { //SPR3362
                vpmsProxy = new NbaVpmsAdaptor(oinkData, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR3362
                vpmsProxy.setVpmsEntryPoint(NbaVpmsAdaptor.EP_RESULTXML);

                // deOink general fields
                deOinkMap.put(NbaVpmsConstants.A_PROCESS_ID, NbaUtils.getBusinessProcessId(getUser())); //SPR2639
                deOinkMap.put("A_Run_Level", String.valueOf(level));

                // call deOink methods
                deOinkImpairmentFields(deOinkMap);
                deOinkProductCode(deOinkMap);
                deOinkFamillyIllnessValues(deOinkMap);
                deOinkPreferredDetailInputs(deOinkMap, level);
                //getRxScoreOINKValues(deOinkMap); // APSL4392, Code commented for APSL4427
                // SPR2652 code deleted
                oinkRequest.setArgs(getKeys());

                vpmsProxy.setANbaOinkRequest(oinkRequest);
                vpmsProxy.setSkipAttributesMap(deOinkMap);
                VpmsComputeResult vcr;
                try {
                    vcr = vpmsProxy.getResults();
                    NbaVpmsResultsData vpmsResultsData = new NbaVpmsResultsData(vcr);
                    results = vpmsResultsData.getResultsData();
                    //Resulting string will be the zeroth element.
                    if (results == null) {
                        //SPR3362 code deleted
                        throw new NbaVpmsException(NbaVpmsException.VPMS_NO_RESULTS + NbaVpmsAdaptor.ACPRFCRITERIA); //SPR2652
                    } //SPR2652
                    vpmsResult = (String) results.get(0);
                    NbaVpmsModelResult vpmsOutput = new NbaVpmsModelResult(vpmsResult);
                    VpmsModelResult vpmModelResult = vpmsOutput.getVpmsModelResult();
                    criteriaImpairments = vpmModelResult.getImpairmentInfo(); //ACN024
                    ArrayList prefInfoList = vpmModelResult.getPreferredInfo();
                    if (prefInfoList != null && prefInfoList.size() != 0) {
                        preferredInfo = vpmModelResult.getPreferredInfoAt(0);
                        // add to criteriaInfoList, but not for level 0
                        if (level > 0) {
                            ArrayList tempCriteriaList = preferredInfo.getCriteriaInfo();
                            if (tempCriteriaList != null && tempCriteriaList.size() > 0) {
                                criteriaInfoListOut.addAll(preferredInfo.getCriteriaInfo());
                            }
                        }
                    }
                    success = true;
                    // SPR2652 code deleted
                    //SPR3362 code deleted
                } catch (RemoteException re) {
                    handleRemoteException(re, NbaVpmsAdaptor.ACPRFCRITERIA); //SPR2652
                    // SPR2652 code deleted
                }
            //begin SPR3362
            } finally {
                if (vpmsProxy != null) {
                    try {
                        vpmsProxy.remove();
                    } catch (RemoteException e) {
                        getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
                    }
                }
            }
            //end SPR3362
		}
		return success;
	}
	
	/**
	 * This function acts as an entry point for calculating the deOink values
	 * required for Criteria calculation	 
	 * @param HashMap: Map to carry deOink values
	 * @param int: preferred level
	 */	
	protected void deOinkPreferredDetailInputs(HashMap deOinkMap, int level) {
		ArrayList criteriaInfoList = null;
		CriteriaInfo criteriaInfo = null;
		// use the sum total of all lists if level = 0
		if (level > 0) {
			criteriaInfoList = criteriaInfoListIn;
		} else {
			criteriaInfoList = criteriaInfoListOut;
		}
		int listSize = criteriaInfoList.size();
		deOinkMap.put("A_no_of_PrefDetail_INS", String.valueOf(listSize));
		for(int i=0;i<listSize;i++){
			criteriaInfo = (CriteriaInfo) criteriaInfoList.get(i);
			if(criteriaInfo!=null){
				if(i==0){
					// send only 2 attributes for level 0
					deOinkMap.put("A_PrfScore_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfScore())));
					deOinkMap.put("A_PrfLevel_INS",convertToDefault(criteriaInfo.getPrfLevel()));
					if(level > 0) {
						deOinkMap.put("A_PrfType_INS",convertToDefault(String.valueOf(criteriaInfo.getPrfType())));
						deOinkMap.put("A_PrfTestCd_INS",convertToDefault(String.valueOf(criteriaInfo.getPrfTestCd())));
						deOinkMap.put("A_PrfValue_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfValue())));
						deOinkMap.put("A_PrfLowRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfLowRange())));
						deOinkMap.put("A_PrfHighRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfHighRange())));			
						deOinkMap.put("A_PrfHeightValue_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfHeightValue())));
						deOinkMap.put("A_PrfHeightRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfHeightRange())));			
						deOinkMap.put("A_PrfUsageCd_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfUsageCd())));
						deOinkMap.put("A_PrfCigaretteCount_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfCigaretteCount())));
						deOinkMap.put("A_PrfSmkQuitMonth_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfSmkQuitMonth())));
						deOinkMap.put("A_PrfTobMonth_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfTobMonth())));
						deOinkMap.put("A_PrfCigaretteCountRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfCigaretteCountRange())));
						deOinkMap.put("A_PrfSmkQuitMonthRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfSmkQuitMonthRange())));
						deOinkMap.put("A_PrfTobMonthRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfTobMonthRange())));
						deOinkMap.put("A_PrfDeathCount_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfDeathCount())));
						deOinkMap.put("A_PrfIncidentCount_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfIncidentCount())));
						deOinkMap.put("A_PrfDeathCountRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfDeathCountRange())));
						deOinkMap.put("A_PrfIncidentCountRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfIncidentCountRange())));			
						deOinkMap.put("A_PrfPriorAgeRange_INS", convertToDefault(String.valueOf(criteriaInfo.getPrfPriorAgeRange())));
						deOinkMap.put("A_PrfQualLabValue_INS", convertToDefault(criteriaInfo.getPrfLabQualValue()));
						deOinkMap.put("A_PrfQualLabRange_INS", convertToDefault(criteriaInfo.getPrfLabQualRange()));
					}
				}else{
					deOinkMap.put("A_PrfScore_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfScore())));
					deOinkMap.put("A_PrfLevel_INS[" + i + "]",convertToDefault(criteriaInfo.getPrfLevel()));
					if(level > 0) {
						deOinkMap.put("A_PrfType_INS[" + i + "]",convertToDefault(String.valueOf(criteriaInfo.getPrfType())));
						deOinkMap.put("A_PrfTestCd_INS[" + i + "]",convertToDefault(String.valueOf(criteriaInfo.getPrfTestCd())));
						deOinkMap.put("A_PrfValue_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfValue())));
						deOinkMap.put("A_PrfLowRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfLowRange())));
						deOinkMap.put("A_PrfHighRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfHighRange())));			
						deOinkMap.put("A_PrfHeightValue_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfHeightValue())));
						deOinkMap.put("A_PrfHeightRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfHeightRange())));			
						deOinkMap.put("A_PrfUsageCd_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfUsageCd())));
						deOinkMap.put("A_PrfCigaretteCount_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfCigaretteCount())));
						deOinkMap.put("A_PrfSmkQuitMonth_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfSmkQuitMonth())));
						deOinkMap.put("A_PrfTobMonth_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfTobMonth())));
						deOinkMap.put("A_PrfCigaretteCountRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfCigaretteCountRange())));
						deOinkMap.put("A_PrfSmkQuitMonthRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfSmkQuitMonthRange())));
						deOinkMap.put("A_PrfTobMonthRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfTobMonthRange())));
						deOinkMap.put("A_PrfDeathCount_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfDeathCount())));
						deOinkMap.put("A_PrfIncidentCount_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfIncidentCount())));
						deOinkMap.put("A_PrfDeathCountRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfDeathCountRange())));
						deOinkMap.put("A_PrfIncidentCountRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfIncidentCountRange())));			
						deOinkMap.put("A_PrfPriorAgeRange_INS[" + i + "]", convertToDefault(String.valueOf(criteriaInfo.getPrfPriorAgeRange())));
						deOinkMap.put("A_PrfQualLabValue_INS[" + i + "]", convertToDefault(criteriaInfo.getPrfLabQualValue()));
						deOinkMap.put("A_PrfQualLabRange_INS[" + i + "]", convertToDefault(criteriaInfo.getPrfLabQualRange()));
					}
				}
			}
		}	
	}
	
	/**
	 * Converts deOink String values to defaults, if null Or Nan
	 * @param String: input String
	 * @return String: converted String
	 */	
	private String convertToDefault(String str) {
		if (str == null || str.equalsIgnoreCase("null")) {
			return "";
		}
		else if (str.equalsIgnoreCase("NaN")) {
			return "-1";
		}
		return str;
	}
	
	/**
	 * This function acts as an entry point for calculating the deOink values
	 * required for Impairments	 
	 * @param HashMap: Map to carry deOink values
	 */	
	protected void deOinkImpairmentFields(HashMap deOinkMap){
		ArrayList impairmentInfoList = nbaTxLife.getImpairments(partyID);
		int count = impairmentInfoList.size();
		ImpairmentInfo impairmentInfo = null;
		deOinkMap.put("A_no_of_Description_INS", String.valueOf(count));
		String impPermFlatExtraAmt = "";
		String impTempFlatExtraAmt = "";
		for(int i=0;i<count;i++){
			impairmentInfo = (ImpairmentInfo) impairmentInfoList.get(i);
			// begin AXAL3.7.08
			impPermFlatExtraAmt = impairmentInfo.getImpairmentPermFlatExtraAmt();
			impTempFlatExtraAmt = impairmentInfo.getImpairmentTempFlatExtraAmt();
			// end AXAL3.7.08
			if(i==0){			
				deOinkMap.put("A_Description_INS", convertToDefault(impairmentInfo.getDescription()));
				deOinkMap.put("A_ImpairmentStatus_INS", convertToDefault(String.valueOf(impairmentInfo.getImpairmentStatus())));
				deOinkMap.put("A_ImpairmentPermFlatExtraAmt_INS", convertToDefault(impPermFlatExtraAmt));
				deOinkMap.put("A_ImpairmentTempFlatExtraAmt_INS", convertToDefault(impTempFlatExtraAmt));
				deOinkMap.put("A_Debit_INS", convertToDefault(String.valueOf(impairmentInfo.getDebit())));
				// begin AXAL3.7.08
				deOinkMap.put("A_ImpairmentClass_INS", convertToDefault(impairmentInfo.getImpairmentClass()));
				deOinkMap.put("A_ImpairmentRestrictApprovalInd_INS",convertToDefault(String.valueOf(impairmentInfo.getRestrictApprovalInd())));//ALS3634
				deOinkMap.put("A_ImpairmentSource_INS", convertToDefault(impairmentInfo.getImpairmentSource()));
				deOinkMap.put("A_ImpairmentType_INS", convertToDefault(impairmentInfo.getImpairmentType()));
				// end AXAL3.7.08
			}else{
				deOinkMap.put("A_Description_INS["+i+"]", convertToDefault(impairmentInfo.getDescription()));
				deOinkMap.put("A_ImpairmentStatus_INS["+i+"]", convertToDefault(String.valueOf(impairmentInfo.getImpairmentStatus())));
				deOinkMap.put("A_ImpairmentPermFlatExtraAmt_INS["+i+"]", convertToDefault(impPermFlatExtraAmt));
				deOinkMap.put("A_ImpairmentTempFlatExtraAmt_INS["+i+"]", convertToDefault(impTempFlatExtraAmt));
				deOinkMap.put("A_Debit_INS["+i+"]", convertToDefault(String.valueOf(impairmentInfo.getDebit())));				
				// begin AXAL3.7.08
				deOinkMap.put("A_ImpairmentClass_INS["+i+"]", convertToDefault(impairmentInfo.getImpairmentClass()));
				deOinkMap.put("A_ImpairmentRestrictApprovalInd_INS["+i+"]",convertToDefault(String.valueOf(impairmentInfo.getRestrictApprovalInd())));//ALS3634
				deOinkMap.put("A_ImpairmentSource_INS["+i+"]", convertToDefault(impairmentInfo.getImpairmentSource()));
				deOinkMap.put("A_ImpairmentType_INS["+i+"]", convertToDefault(impairmentInfo.getImpairmentType()));
				// end AXAL3.7.08
			}
		}
	}

	/**
	 * This function acts as an entry point for calculating the deOink values
	 * required for ProductCodes	 
	 * @param HashMap: Map to carry deOink values
	 */	
	protected void deOinkProductCode(HashMap deOinkMap){
		ArrayList coverageList = nbaTxLife.getCoveragesFor(partyID);
		ArrayList productCodeList = new ArrayList();
		int count = coverageList.size();
		Coverage coverage = null;
		String productCode = null;
		for(int i=0;i<count;i++){
			coverage = (Coverage)coverageList.get(i);
			if(coverage!=null){
				productCode = coverage.getProductCode();
				if(productCode!=null && !productCode.equals("")){
					productCodeList.add(productCode);
				}
			}
		}
		int productCodeCount = productCodeList.size();
		deOinkMap.put("A_no_of_ProductCode_INS",String.valueOf(productCodeCount));
		if(productCodeCount==0){
			deOinkMap.put("A_ProductCode_INS","");
		}else{
			for(int i=0;i<productCodeCount;i++){
				if(i==0){
					deOinkMap.put("A_ProductCode_INS",(String)productCodeList.get(i));
				}else{
					deOinkMap.put("A_ProductCode_INS["+i+"]",(String)productCodeList.get(i));
				}
			}
		}
	}
	
	/**
	 * This function acts as an entry point for calculating the deOink values
	 * required for Family Illness	 
	 * @param HashMap: Map to carry deOink values
	 */	
	protected void deOinkFamillyIllnessValues(HashMap deOinkMap) throws IndexOutOfBoundsException, NbaBaseException{ //SPR2652 added throws
		Party party = null;
		if (performingContractEvaluation()) { //SPR2652
			party = nbaTxLife.getParty(partyID).getParty();		
		} else if (performingRequirementsEvaluation()) { //SPR2652
			party = txLifeReqResult.getOLifE().getPartyAt(0);
		}
		
		Risk risk = null;
		ArrayList familyIllnessList = null;
		FamilyIllness familyIllness = null;
		//begin AXAL3.7.08
		FamilyIllnessExtension familyIllnessExtension = null;
		boolean historyUnknownInd = false;
		int index_extension = 0;
		//end AXAL3.7.08
		int size = 0;
		if(party!=null){
			risk = party.getRisk();
			if(risk!=null){
				familyIllnessList = risk.getFamilyIllness();
			}
		}
		if(familyIllnessList!=null){
			size = familyIllnessList.size();
		}
		deOinkMap.put("A_no_of_FamilyDiagnosis_INS",String.valueOf(size));
		for(int i=0;i<size;i++){
			familyIllness = (FamilyIllness) familyIllnessList.get(i);
			if(familyIllness!=null){
				//begin AXAL3.7.08
				familyIllnessExtension = NbaUtils.getFirstFamilyIllnessExtension(familyIllness);
               	if (familyIllnessExtension != null) {
               		historyUnknownInd = familyIllnessExtension.getHistoryUnknownInd();
                }
                else {
                	historyUnknownInd = false;
                }
				//end AXAL3.7.08
				if(i==0){
					deOinkMap.put("A_FamilyDiagnosis_INS",convertToDefault(String.valueOf(familyIllness.getDiagnosis())));
					deOinkMap.put("A_AgeAtDeath_INS",convertToDefault(String.valueOf(familyIllness.getAgeAtDeath())));
					deOinkMap.put("A_OnSetAge_INS",convertToDefault(String.valueOf(familyIllness.getOnsetAge())));					
					//begin AXAL3.7.08
					deOinkMap.put("A_HistoryUnknownInd_INS",convertToDefault(String.valueOf(historyUnknownInd)));
					deOinkMap.put("A_RoleCodeDesc_INS",convertToDefault(String.valueOf(familyIllness.getRoleCodeDesc())));
					//end AXAL3.7.08
					}else{
					deOinkMap.put("A_FamilyDiagnosis_INS["+i+"]",convertToDefault(String.valueOf(familyIllness.getDiagnosis())));
					deOinkMap.put("A_AgeAtDeath_INS["+i+"]",convertToDefault(String.valueOf(familyIllness.getAgeAtDeath())));
					deOinkMap.put("A_OnSetAge_INS["+i+"]",convertToDefault(String.valueOf(familyIllness.getOnsetAge())));					
					//begin AXAL3.7.08
					deOinkMap.put("A_HistoryUnknownInd_INS["+i+"]",convertToDefault(String.valueOf(historyUnknownInd)));
					deOinkMap.put("A_RoleCodeDesc_INS["+i+"]",convertToDefault(String.valueOf(familyIllness.getRoleCodeDesc())));
					//end AXAL3.7.08
				}
			}
		}
	}

	/**
	 * This function acts as an entry point for calculating the deOink values
	 * required for Lab Tests	 
	 * @param HashMap: Map to carry deOink values
	 */	
	//This function is only used in Req Eval
	protected void getLabTestDeOINKValues(HashMap deOinkMap) throws NbaBaseException {
		String testCode = "";
		String[] testCodeList = null;
		String labValue = "";
		String[] labValueList = null;
		int testCodeCount = 0;
		int labValueCount = 0;		
		NbaOinkDataAccess accessContract = new NbaOinkDataAccess(txLifeReqResult);
		NbaOinkRequest oinkRequest = new NbaOinkRequest();
		oinkRequest.setVariable("LabTestCode");
		oinkRequest.setRequirementIdFilter(reqId);
		//begin ALS4576
		int partyIndex = -1;
		for (int a=0;a<txLifeReqResult.getOLifE().getPartyCount();a++) {
			if (txLifeReqResult.getOLifE().getPartyAt(a).getId().equalsIgnoreCase(this.reqRelatePartyID)) {
				partyIndex = a;
				break;
			}
		}
		if (partyIndex > 0) {   //default in OINK process is 0 so only set when greater than 0...ie not first party
			oinkRequest.setPartyFilter(partyIndex); 
		}
		//end ALS4576
		testCodeList = accessContract.getStringValuesFor(oinkRequest);
		testCodeCount = testCodeList.length;
		deOinkMap.put("A_no_of_LabTestCode", (new Integer(testCodeCount)).toString());
		for (int i = 0; i < testCodeCount; i++) {
			testCode = testCodeList[i];
			if (i == 0) {
				deOinkMap.put("A_LabTestCode", testCode);
			} else {
				deOinkMap.put("A_LabTestCode[" + i + "]", testCode);
			}
			oinkRequest.setVariable("LabValue");
			oinkRequest.setRequirementIdFilter(reqId);
			oinkRequest.setLabTestCodeFilter(testCode);
			labValueList = accessContract.getStringValuesFor(oinkRequest);
			labValueCount = labValueList.length;
			if (i == 0) {
				deOinkMap.put("A_no_of_LabValue", (new Integer(labValueCount)).toString());
			} else {
				deOinkMap.put("A_no_of_LabValue[" + i + "]", (new Integer(labValueCount)).toString());
			}
			for (int j = 0; j < labValueCount; j++) {
				labValue = labValueList[j];
				if (i == 0 && j == 0) {
					deOinkMap.put("A_LabValue", labValue);
				} else {
					deOinkMap.put("A_LabValue[" + i + "," + j + "]", labValue);
				}
			}
		}
	}	

	/**
	 * This function updates the PreferredInfoList
	 * @param String: partyId
	 * @param ArrayList: prefInfoList
	 */	
	protected void updatePreferredInfoList(String partyId, ArrayList prefInfoList) throws NbaBaseException {
		if (prefInfoList != null && prefInfoList.size() != 0) {
			Party party = nbaTxLife.getParty(partyId).getParty();
			UnderwritingAnalysis underwritingAnalysis = null;
			PartyExtension partyExtension = null;
			if (party != null) {
				party.setActionUpdate();
				partyExtension = NbaUtils.getFirstPartyExtension(party);
				if (partyExtension == null) {
					OLifEExtension oli = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_PARTY);
					oli.setActionAdd();
					party.addOLifEExtension(oli);
					partyExtension = oli.getPartyExtension();
					partyExtension.setActionAdd();
				}
				underwritingAnalysis = partyExtension.getUnderwritingAnalysis();
				partyExtension.setActionUpdate();
				if (underwritingAnalysis == null) {
					underwritingAnalysis = new UnderwritingAnalysis();
					underwritingAnalysis.setActionAdd();
					partyExtension.setUnderwritingAnalysis(underwritingAnalysis);
				}
				underwritingAnalysis.setActionUpdate();
				updatePreferredInfo(underwritingAnalysis, (PreferredInfo)prefInfoList.get(0));
			}
		}
	}
	
	/**
	 * This function updates the PreferredInfo Object
	 * @param UnderwritingAnalysis: underwritingAnalysis
	 * @param PreferredInfo: preferredInfo
	 */	
	protected void updatePreferredInfo(UnderwritingAnalysis underwritingAnalysis, PreferredInfo preferredInfo) {
		if (preferredInfo != null) {
			PreferredInfo preferredInfo2 = underwritingAnalysis.getPreferredInfo();
			if (preferredInfo2 == null) {
				preferredInfo2 = new PreferredInfo();
				preferredInfo2.setActionAdd();
			}
			preferredInfo2.setActionUpdate();
			preferredInfo2.setPrfSet(preferredInfo.getPrfSet());
			preferredInfo2.setPrfApprovedLevel(preferredInfo.getPrfApprovedLevel());
			preferredInfo2.setPrfCalculatedLevel(preferredInfo.getPrfCalculatedLevel());
			preferredInfo2.setPrfTobaccoPremiumBasis(preferredInfo.getPrfTobaccoPremiumBasis());
		
			// delete Input CriteriaInfoList
			ArrayList criteriaInfoListIn = preferredInfo2.getCriteriaInfo();
			CriteriaInfo cInfoIn = null;
			for (int i=0; i< criteriaInfoListIn.size(); i++) {
				cInfoIn = (CriteriaInfo)criteriaInfoListIn.get(i);
				cInfoIn.setActionDelete();
			}
		
			// add Output CriteriaInfoList
			CriteriaInfo cInfoOut = null;
			NbaOLifEId nbaOLifEId = new NbaOLifEId(nbaTxLife);
			for (int i=0; i< criteriaInfoListOut.size(); i++) {
				cInfoOut = (CriteriaInfo)criteriaInfoListOut.get(i);
				nbaOLifEId.setId(cInfoOut);
				cInfoOut.setPrfOrder(i);  //AXAL3.7.08
				preferredInfo2.addCriteriaInfo(cInfoOut);
				cInfoOut.setActionAdd();
			}
			underwritingAnalysis.setPreferredInfo(preferredInfo2);
		}
	}
	
	// APSL4278 new method
	protected void getRxScoreOINKValues(HashMap deOinkMap) throws NbaBaseException {
		String[] scoreList = null;
		NbaTXLife attachmentTxLife = null;
		List reqInfoList = new ArrayList();
		RequirementInfo reqInfo = null;
		reqInfoList = nbaTxLife.getRequirementInfoList(partyID, NbaOliConstants.OLI_REQCODE_PPR);
		for (int i = 0; i < reqInfoList.size(); i++) {
			reqInfo = (RequirementInfo) reqInfoList.get(i);
			if (reqInfo.getReqStatus() == NbaOliConstants.OLI_REQSTAT_RECEIVED) {
				ArrayList attachmentList = reqInfo.getAttachment();
				if (attachmentList != null) {
					for (int j = 0; j < attachmentList.size(); j++) {
						Attachment attachment = (Attachment) attachmentList.get(j);
						if (attachment.getAttachmentType() == NbaOliConstants.OLI_ATTACH_REQUIRERESULTS) {
							String attachmentdataTxlife = attachment.getAttachmentData().getPCDATA();
							try {
								if (attachmentdataTxlife != null) {
									attachmentTxLife = new NbaTXLife(attachmentdataTxlife);
								}
							} catch (Exception e) {
								e.printStackTrace();
								throw new NbaBaseException();
							}
							break;
						}
					}
					if (attachmentTxLife != null) {
						NbaOinkDataAccess accessContract = new NbaOinkDataAccess(attachmentTxLife);
						NbaOinkRequest oinkRequest = new NbaOinkRequest();
						oinkRequest.setVariable("HighestSingleScore");
						scoreList = accessContract.getStringValuesFor(oinkRequest);
						if (scoreList.length > 0 && !NbaUtils.isEmpty(scoreList[0])) { // APSL4406
							deOinkMap.put("A_HighestSingleScore", convertToDefault(scoreList[0])); // APSL4406
						}
						oinkRequest.setVariable("OverallRiskScore");
						accessContract.getStringValuesFor(oinkRequest);
						scoreList = accessContract.getStringValuesFor(oinkRequest);
						if (scoreList.length > 0 && !NbaUtils.isEmpty(scoreList[0])) { // APSL4406
							deOinkMap.put("A_OverallRiskScore", convertToDefault(scoreList[0])); // APSL4406
						}
						break;
					}
				}
			}
		}
	} 
	
}
