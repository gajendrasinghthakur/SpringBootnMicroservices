package com.csc.fsg.nba.business.process.evaluation;

/*
 * **************************************************************************<BR>
 * This program contains trade secrets and confidential information which<BR>
 * are proprietary to CSC Financial Services Group®.  The use,<BR>
 * reproduction, distribution or disclosure of this program, in whole or in<BR>
 * part, without the express written permission of CSC Financial Services<BR>
 * Group is prohibited.  This program is also an unpublished work protected<BR>
 * under the copyright laws of the United States of America and other<BR>
 * countries.  If this program becomes published, the following notice shall<BR>
 * apply:
 *     Property of Computer Sciences Corporation.<BR>
 *     Confidential. Not for publication.<BR>
 *     Copyright (c) 2002-2008 Computer Sciences Corporation. All Rights Reserved.<BR>
 * **************************************************************************<BR>
 */

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashMap;

import com.csc.fsg.nba.datamanipulation.NbaOinkDataAccess;
import com.csc.fsg.nba.datamanipulation.NbaOinkRequest;
import com.csc.fsg.nba.exception.NbaBaseException;
import com.csc.fsg.nba.exception.NbaVpmsException;
import com.csc.fsg.nba.foundation.NbaConstants;
import com.csc.fsg.nba.foundation.NbaOliConstants;
import com.csc.fsg.nba.foundation.NbaUtils;
import com.csc.fsg.nba.vo.NbaAcdb;
import com.csc.fsg.nba.vo.NbaTXLife;
import com.csc.fsg.nba.vo.txlife.FormInstance;
import com.csc.fsg.nba.vo.txlife.FormResponse;
import com.csc.fsg.nba.vo.txlife.ImpairmentInfo;
import com.csc.fsg.nba.vo.txlife.MedicalCondition;
import com.csc.fsg.nba.vo.txlife.MedicalTreatment;
import com.csc.fsg.nba.vo.txlife.OLifE;
import com.csc.fsg.nba.vo.txlife.Party;
import com.csc.fsg.nba.vo.txlife.Person;
import com.csc.fsg.nba.vo.txlife.PersonExtension;
import com.csc.fsg.nba.vo.txlife.Policy;
import com.csc.fsg.nba.vo.txlife.RequirementInfo;
import com.csc.fsg.nba.vo.txlife.Risk;
import com.csc.fsg.nba.vo.txlife.Violation;
import com.csc.fsg.nba.vpms.NbaVpmsAdaptor;
import com.csc.fsg.nba.vpms.NbaVpmsModelResult;
import com.csc.fsg.nba.vpms.NbaVpmsResultsData;
import com.csc.fsg.nba.vpms.results.VpmsModelResult;

/**
 * Class that will take care of the processing once ACAviationEvaluation model is invoked 
 * from NBCTEVAL and NBRQEVAL process.
 * <p>Implements NbaVpmsModelProcessor 
 * <p>
 * <b>Modifications:</b><br>
 * <table border=0 cellspacing=5 cellpadding=5>
 * <thead>
 * <th align=left>Project</th><th align=left>Release</th><th align=left>Description</th>
 * </thead>
 * <tr><td>ACP016</td><td>Version 4</td><td>Aviation Evaluation</td></tr>
 * <tr><td>ACN016</td><td>Version 4</td><td>PnR MB2</td></tr>
 * <tr><td>SPR2652</td><td>Version 5</td><td>APCTEVAL process getting error stopped with Run time error occured message</td><tr>
 * <tr><td>SPR3329</td><td>Version 7</td><td>Prevent erroneous "Retrieve variable name is invalid" messages from being generated by OINK</td></tr>
 * <tr><td>SPR3362</td><td>Version 7</td><td>Exceptions in Automated Processes and Logon Service Due to VP/MS Memory Leak</td></tr>
 * <tr><td>SPR3290</td><td>Version 7</td><td>General source code clean up during version 7</td></tr>
 * </table>
 * <p>
 * @author CSC FSG Developer
 * @version 7.0.0
 * @since New Business Accelerator - Version 4
 */

public class NbaACAviationEvaluationProcessor extends NbaVpmsModelProcessor {

	protected ArrayList aviationImpairments =new ArrayList();
	protected ArrayList accepAviationImpairments = null;	
	String modelName = NbaVpmsAdaptor.AC_AVIATIONEVALUATION;
	String entryPoint = NbaVpmsAdaptor.EP_RESULTXML;
	protected NbaTXLife holdingOrReqResult = null;
	// Will hold the partyId of 1122 or from the holdingInquiry. partyID holds the id of the insured from holdingInquiry.
	protected String processingPartyId = null;
	
	/**
	 * Overridden method, calls the model and 
	 * updates the contract with impairments.
	 * @throws NbaBaseException
	 */
	public void execute() throws NbaBaseException {
		
		boolean isSuccess = false;
		impSrc = NbaConstants.AVIATION_SRC; //ACN016
		if(performingContractEvaluation()){	//SPR2652
			holdingOrReqResult = nbaTxLife;
			int partyIndex = 0;
			ArrayList al = getAllInsuredIndexes();
			OLifE oLifE = nbaTxLife.getOLifE();
			// SPR3290 code deleted
			int insuredCount = al.size();
			for(int i=0;i<insuredCount;i++){
				partyIndex = ((Integer)al.get(i)).intValue();
				processingPartyId = oLifE.getPartyAt(partyIndex).getId();
				partyID = processingPartyId;
				// SPR3290 code deleted
				aviationImpairments.clear();				
				isSuccess = evaluateAviation(i);														
				if (!isSuccess){
					throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + modelName);	//SPR2652
				}
				getContractImpairments(processingPartyId);
				ArrayList[] mergedLists = mergeImpairments(contractImpairments, aviationImpairments, new ArrayList(), new ArrayList());
				ArrayList arrMerged = mergedLists[0];
				addImpairmentInfo(processingPartyId, arrMerged);						
			}
		}
		else if(performingRequirementsEvaluation()){	//SPR2652
			    holdingOrReqResult = txLifeReqResult;
				int relationCode = work.getNbaLob().getReqPersonCode();
				int personSeq = 0;
				processingPartyId = txLifeReqResult.getPartyId(relationCode,String.valueOf(personSeq));
				setPartyID(work);
				isSuccess = evaluateAviation();
				if (!isSuccess) {
					throw new NbaVpmsException(NbaVpmsException.VPMS_RESULTS_ERROR + modelName); //SPR2652
				}
				mergeImpairmentsAndAccep(aviationImpairments,accepAviationImpairments);							
			}
		}
		
		
	/**
	 * This function acts as an entry point for calling the ACAVIATIONEVALUATION model	 
	 * @param partyIndex: Index of the insured
	 * @return boolean : Returns true if the call is successful
	 * 					 Else returns false 	
	 * @throws NbaBaseException
	 */
	//ACP016 New Method
	public boolean evaluateAviation(int insuredIndex) throws NbaBaseException{
		boolean success = true;
		Party party = holdingOrReqResult.getParty(processingPartyId).getParty();
		Risk risk = null;
		ArrayList elementList = null;
		int count = 0;
		if(party!=null){
			risk = party.getRisk();
			if(risk!=null){
				//Call the VPMS model for each Life Style Activity Object
				elementList = risk.getLifeStyleActivity();
				count = elementList.size();
				for(int i=0; i< count; i++){					
					success = retrieveAviationModelResult(insuredIndex,i);
					if(!success){
						return success;
					}
				}
			}
		}
		return success;
	}
	
	
	/**
	 * This method is used to call the ACAviationEvaluation model	 
	 * @param 
	 * @return boolean : Returns true if the call is successful
	 * 					 Else returns false 	
	 * @throws NbaBaseException
	 */
	//ACP016 new method.
	public boolean retrieveAviationModelResult(int insuredIndex,int elementIndex) throws NbaBaseException{
		boolean success = false;
		// SPR2652 code deleted	
		NbaOinkRequest oinkRequest = new NbaOinkRequest();
		oinkRequest.setArgs(getKeys());
		if (updatePartyFilterInRequest(oinkRequest, processingPartyId)) { //SPR2652
			oinkRequest.setRelatedObjectTypeFilter(String.valueOf(NbaOliConstants.OLI_LIFESTYLEACTIVITY));
			oinkRequest.setElementIndexFilter(elementIndex);
			HashMap deOink = new HashMap();
			deOink = deOINKAviationValues(NbaOliConstants.OLI_LIFESTYLEACTIVITY, elementIndex);
			success = invokeVPMSModel(oinkRequest, deOink);
		} //SPR2652
		// SPR2652 code deleted	
		return success;
	}
	
	


	
	/**
	 * This method gets all the deOink variables for ACAviationEvalution model	 
	 * @param 
	 * @return java.util.Map : The Hash Map containing all the deOink variables 	
	 * @throws NbaBaseException
	 */
	//ACP016 new method.
	public HashMap deOINKAviationValues(long relatedObjectType,int elementIndex) throws NbaBaseException{
		// SPR3290 code deleted
		HashMap deOink = new HashMap();
		// SPR3290 code deleted
		deOINKFormResponseData(deOink,relatedObjectType,elementIndex);
		deOINKImpairmentData(deOink);	
		deOINKViolationData(deOink);	
		deOINKRequirementData(deOink);
		deOINKTreatmentAmt(deOink);
		return deOink;
	}
	
	/**
	 * Calls the vpms model. General method can be moved to base class
	 * @param oinkRequest
	 * @param deOink
	 * @return
	 * @throws NbaBaseException
	 */
	//	ACP016 new method.
	public boolean invokeVPMSModel(NbaOinkRequest oinkRequest, HashMap deOink) throws NbaBaseException {
		// SPR3290 code deleted
		boolean success = false;
		ArrayList results = null;		
		ArrayList tempImpairmentList = null;
		NbaOinkDataAccess accessContract;
		NbaVpmsAdaptor vpmsProxy = null; //SPR3362
		try {
			accessContract = new NbaOinkDataAccess(holdingOrReqResult);
			accessContract.setLobSource(work.getNbaLob());
			accessContract.setAcdbSource(new NbaAcdb(), holdingOrReqResult);
			accessContract.setContractSource(holdingOrReqResult); //SPR3329
			vpmsProxy = new NbaVpmsAdaptor(accessContract, modelName); //SPR3362
			vpmsProxy.setVpmsEntryPoint(entryPoint);
			vpmsProxy.setANbaOinkRequest(oinkRequest);
			vpmsProxy.setSkipAttributesMap(deOink);
			NbaVpmsResultsData vpmsResultsData = new NbaVpmsResultsData(vpmsProxy.getResults());
			vpmsResultsData.displayResultsData();
			results = vpmsResultsData.getResultsData();
			if (vpmsResultsData.getResult().isError()) {
				//SPR3362 code deleted
				throw new NbaVpmsException(NbaVpmsException.VPMS_NO_RESULTS + modelName); //SPR2652
			}
			// SPR2652 Code Deleted
			vpmsResult = (String)results.get(0);
			NbaVpmsModelResult vpmsOutput = new NbaVpmsModelResult(vpmsResult);
			if (getLogger().isDebugEnabled()) { 
				getLogger().logDebug(vpmsResult);
			}
			VpmsModelResult vpmsModelResult = vpmsOutput.getVpmsModelResult();
			tempImpairmentList = vpmsModelResult.getImpairmentInfo();
			if(tempImpairmentList!=null && tempImpairmentList.size() != 0){
				aviationImpairments.addAll(tempImpairmentList);
			}
			success = true;
			// SPR2652 code deleted
			//SPR3362 code deleted
		}
		// SPR2652 code deleted
		catch (RemoteException re) {
			handleRemoteException(re, modelName);	//SPR2652
		//begin SPR3362
		} finally {
		    if(vpmsProxy != null){
		        try {
                    vpmsProxy.remove();
                } catch (RemoteException e) {
                    getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
                }
		    }
		//end SPR3362
		}

		return success;
	}
	
	/**
	 * deOinks FormResponse.
	 * @param deOink
	 * @param partyID
	 * @param relatedObjectType
	 * @param elementIndex
	 */
	//	ACP016 new method.
	public void deOINKFormResponseData(HashMap deOink,long relatedObjectType, int elementIndex){
		
		FormInstance formInstance = holdingOrReqResult.getFormInstanceByRelatedObjectType(processingPartyId,relatedObjectType,elementIndex);
		// SPR3290 code deleted
		if(formInstance !=null){
			int queNo = 0;
			int listSize = formInstance.getFormResponseCount();
			FormResponse formResponse = null;
			boolean queOneExists = false;
			for(int i =0; i<listSize ; i++){
				formResponse = formInstance.getFormResponseAt(i);
				queNo = Integer.parseInt(formResponse.getQuestionNumber());				
				if(queNo == 1){
						deOink.put("A_FormResponseCode",String.valueOf(formResponse.getResponseCode()));
						queOneExists = true;
				}
				else{
					deOink.put("A_FormResponseCode["+(queNo-1)+"]",String.valueOf(formResponse.getResponseCode()));
				}
			}
			if(!queOneExists){
				deOink.put("A_FormResponseCode",String.valueOf(0));
			}
			deOink.put("A_no_of_FormResponseCode", String.valueOf(listSize));
		}
		else{
			deOink.put("A_FormResponseCode",String.valueOf(0));
			deOink.put("A_no_of_FormResponseCode", String.valueOf(0));				
		}
		return;
	}
	
	/**
	 * deOINKS impairment fields
	 * @param deOink
	 */
	//	ACP016 new method.	
	public void deOINKImpairmentData(HashMap deOink){
		Party party = holdingOrReqResult.getParty(processingPartyId).getParty();
		Person person = party.getPersonOrOrganization().getPerson();
		PersonExtension personExt = NbaUtils.getFirstPersonExtension(person);
		 if(personExt!=null) {
			int countImpairment = personExt.getImpairmentInfoCount();
			ImpairmentInfo impInfo = null;
			for(int i=0;i<countImpairment;i++){
				impInfo = personExt.getImpairmentInfoAt(i);
				if(i==0){
					deOink.put("A_IMPAIRMENTCLASS_INS",impInfo.getImpairmentClass());
					deOink.put("A_IMPAIRMENTSTATUS_INS",String.valueOf(impInfo.getImpairmentStatus()));
					deOink.put("A_IMPAIRMENTTYPE_INS",impInfo.getImpairmentType());
					deOink.put("A_IMPAIRMENTRESTRICTAPPROVALIND_INS",String.valueOf(impInfo.getRestrictApprovalInd()));//ALS3634
				}else{
					deOink.put("A_IMPAIRMENTCLASS_INS["+i+"]",impInfo.getImpairmentClass());
					deOink.put("A_IMPAIRMENTSTATUS_INS["+i+"]",String.valueOf(impInfo.getImpairmentStatus()));
					deOink.put("A_IMPAIRMENTTYPE_INS["+i+"]",impInfo.getImpairmentType());
					deOink.put("A_IMPAIRMENTRESTRICTAPPROVALIND_INS["+i+"]",String.valueOf(impInfo.getRestrictApprovalInd()));//ALS3634
				}
			}
			deOink.put("A_NO_OF_IMPAIRMENTS", String.valueOf(countImpairment));
		 }
	}
	
	/**
	 * deOINKS violation fields.
	 * @param deOink
	 */
	//	ACP016 new method.
	public void deOINKViolationData(HashMap deOink){
		Party party = holdingOrReqResult.getParty(processingPartyId).getParty();
		if(party!=null){
			Risk risk = party.getRisk();
			if(risk!= null){
				int countViolation = risk.getViolationCount();
				Violation violation = null;
				for(int i=0;i<countViolation;i++){
					violation = risk.getViolationAt(i);
					if(i==0){
						deOink.put("A_VIOLATIONDATE_INS",NbaUtils.getDateWithoutSeparator(violation.getViolationDate()));
						deOink.put("A_VIOLATIONTYPE_INS",String.valueOf(violation.getViolationType()));
					}
				}
				deOink.put("A_VIOLATIONTYPE_COUNT", String.valueOf(countViolation));
			}
		}

	}
	
	/**
	 * deOINKS requirement fields.
	 * @param deOink
	 */
	//	ACP016 new method.
	public void deOINKRequirementData(HashMap deOink){
		Policy policy = holdingOrReqResult.getPolicy();
		int countReq = policy.getRequirementInfoCount();
		RequirementInfo reqInfo = null;
		for (int i = 0; i < countReq; i++) {
			reqInfo = policy.getRequirementInfoAt(i);
			if (reqInfo != null) {
				deOink.put("A_REQCODE_INS", String.valueOf(reqInfo.getReqCode()));
			}
		}
		deOink.put("A_NO_OF_REQUIREMENTS",String.valueOf(countReq));

	}
	
	
	/**
	 * @return true if model successfully returned result.
	 * @throws NbaBaseException
	 */
	//ACP016 New Method
	public boolean evaluateAviation() throws NbaBaseException{
		boolean success = true;
		Party party = holdingOrReqResult.getParty(processingPartyId).getParty();
		Risk risk = null;
		ArrayList elementList = null;
		int count = 0;
		if(party!=null){
			risk = party.getRisk();
			if(risk!=null){
				//Call the VPMS model for each Life Style Activity Object
				elementList = risk.getLifeStyleActivity();
				count = elementList.size();
				for(int i=0; i< count; i++){					
					success = retrieveAviationModelResult(i);
					if(!success){
						return success;
					}
				}
			}
		}
		return success;
	}
	
	

	/**
	 * This method is used to call the Aviation model	 
	 * @param 
	 * @return boolean : Returns true if the call is successful
	 * 					 Else returns false 	
	 * @throws NbaBaseException
	 */
	//ACP016 new method.
	public boolean retrieveAviationModelResult(int elementIndex) throws NbaBaseException{
		boolean success = true;
		// SPR3290 code deleted
		try{		
			NbaOinkRequest oinkRequest = new NbaOinkRequest();
			oinkRequest.setArgs(getKeys());
			oinkRequest.setRelatedObjectTypeFilter(String.valueOf(NbaOliConstants.OLI_LIFESTYLEACTIVITY));
			oinkRequest.setElementIndexFilter(elementIndex);

			HashMap deOink = new HashMap();
			deOink = deOINKAviationValues(NbaOliConstants.OLI_LIFESTYLEACTIVITY, elementIndex);
			success = invokeVPMSModel(oinkRequest,deOink); 
		}
		catch(NbaVpmsException nve){
			throw new NbaBaseException("NbaVpmsException Exception occured in callAviationEvaluation",nve);
		}
		catch(Exception e){
			throw new NbaBaseException("Exception occured in callAviationEvaluation",e);
		}		
		return success;
	}
	
	/**
	 * Sums treatment amount and adds to the deOINK map. 
	 * @param deOink
	 * @throws NbaBaseException
	 */
	public void deOINKTreatmentAmt(HashMap deOink) throws NbaBaseException{
		Party party = holdingOrReqResult.getParty(processingPartyId).getParty();
		Risk risk = null;
		// SPR3290 code deleted
		int sumTreatmentAmt = 0;
		if(party!=null){
			risk = party.getRisk();
			if(risk!=null){
				ArrayList medConditionList = new ArrayList();
				ArrayList medTreatmentAmtList = new ArrayList();
				medConditionList = risk.getMedicalCondition();
				int medConditionCount = risk.getMedicalConditionCount();
				int medTreatmentAmtCount =0;
				MedicalCondition medCondition = null;
				MedicalTreatment medTreatment = null;
				int treatmentAmt = 0;
				for(int i=0;i<medConditionCount;i++){
					medCondition = ((MedicalCondition)medConditionList.get(i));
					medTreatmentAmtList = medCondition.getMedicalTreatment();
					medTreatmentAmtCount = medCondition.getMedicalTreatmentCount();
					for(int j=0;j<medTreatmentAmtCount;j++){
						medTreatment = ((MedicalTreatment)medTreatmentAmtList.get(j));
						treatmentAmt = medTreatment.getTreatmentAmt();
						sumTreatmentAmt += treatmentAmt;
					}
					
				}
			}
		}
		deOink.put("A_TreatmentAmt_INS", String.valueOf(sumTreatmentAmt));				
	}
}
