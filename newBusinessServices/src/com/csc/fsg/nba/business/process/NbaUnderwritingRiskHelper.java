package com.csc.fsg.nba.business.process;

/*
 * *******************************************************************************<BR>
 * This program contains trade secrets and confidential information which<BR>
 * are proprietary to CSC Financial Services Groupï¿½.  The use,<BR>
 * reproduction, distribution or disclosure of this program, in whole or in<BR>
 * part, without the express written permission of CSC Financial Services<BR>
 * Group is prohibited.  This program is also an unpublished work protected<BR>
 * under the copyright laws of the United States of America and other<BR>
 * countries.  If this program becomes published, the following notice shall<BR>
 * apply:
 *     Property of Computer Sciences Corporation.<BR>
 *     Confidential. Not for publication.<BR>
 *     Copyright (c) 2002-2008 Computer Sciences Corporation. All Rights Reserved.<BR>
 * *******************************************************************************<BR>
 */

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import com.csc.fsg.nba.datamanipulation.NbaOinkDataAccess;
import com.csc.fsg.nba.datamanipulation.NbaOinkRequest;
import com.csc.fsg.nba.exception.NbaBaseException;
import com.csc.fsg.nba.foundation.NbaBootLogger;
import com.csc.fsg.nba.foundation.NbaConstants;
import com.csc.fsg.nba.foundation.NbaLogFactory;
import com.csc.fsg.nba.foundation.NbaLogger;
import com.csc.fsg.nba.foundation.NbaOLifEId;
import com.csc.fsg.nba.foundation.NbaObjectPrinter;
import com.csc.fsg.nba.foundation.NbaOliConstants;
import com.csc.fsg.nba.foundation.NbaUtils;
import com.csc.fsg.nba.vo.NbaAcdb;
import com.csc.fsg.nba.vo.NbaDst;
import com.csc.fsg.nba.vo.NbaHolding;
import com.csc.fsg.nba.vo.NbaTXLife;
import com.csc.fsg.nba.vo.NbaTXRequestVO;
import com.csc.fsg.nba.vo.NbaUserVO;
import com.csc.fsg.nba.vo.txlife.ApplicationInfo;
import com.csc.fsg.nba.vo.txlife.ApplicationInfoExtension;
import com.csc.fsg.nba.vo.txlife.Attachment;
import com.csc.fsg.nba.vo.txlife.AttachmentData;
import com.csc.fsg.nba.vo.txlife.CovOption;
import com.csc.fsg.nba.vo.txlife.Coverage;
import com.csc.fsg.nba.vo.txlife.CoverageExtension;
import com.csc.fsg.nba.vo.txlife.Holding;
import com.csc.fsg.nba.vo.txlife.Life;
import com.csc.fsg.nba.vo.txlife.LifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty;
import com.csc.fsg.nba.vo.txlife.LifeParticipant;
import com.csc.fsg.nba.vo.txlife.OLifE;
import com.csc.fsg.nba.vo.txlife.OLifEExtension;
import com.csc.fsg.nba.vo.txlife.Party;
import com.csc.fsg.nba.vo.txlife.Person;
import com.csc.fsg.nba.vo.txlife.PersonExtension;
import com.csc.fsg.nba.vo.txlife.PersonOrOrganization;
import com.csc.fsg.nba.vo.txlife.Policy;
import com.csc.fsg.nba.vo.txlife.PolicyExtension;
import com.csc.fsg.nba.vo.txlife.Relation;
import com.csc.fsg.nba.vo.txlife.RelationExtension;
import com.csc.fsg.nba.vo.txlife.Risk;
import com.csc.fsg.nba.vo.txlife.RiskExtension;
import com.csc.fsg.nba.vpms.NbaVpmsAdaptor;
import com.csc.fsg.nba.vpms.NbaVpmsConstants;
import com.csc.fsg.nba.vpms.NbaVpmsPartyInquiryRequestData;
import com.csc.fsg.nba.vpms.NbaVpmsUnderwritingRiskData;
/**
 * It is a helper class for calculating underwriting risk on a contract 
 * <p>
 * <b>Modifications:</b><br>
 * <table border=0 cellspacing=5 cellpadding=5>
 * <thead>
 * <th align=left>Project</th><th align=left>Release</th><th align=left>Description</th>
 * </thead>
 * <tr><td>NBA105</td><td>Version 4</td><td>Underwriting Risk</td></tr>
 * <tr><td>SPR2149</td><td>Version 4</td><td>Face amount LOB is not set when Current amount has 9 or more digits</td></tr>
 * <tr><td>SPR2366</td><td>Version 4.1</td><td>Added unique file names for webservice stubs</td></tr>
 * <tr><td>SPR2639</td><td>Version 5</td><td>Automated process status should be based business function</td></tr>
 * <tr><td>NBA124</td><td>Version 5</td><td>Underwriting Risk Remap</td></tr>
 * <tr><td>SPR2743</td><td>Version 5</td><td>Pending database party inquiry during underwriting risk processing producing enormous matches</td></tr>
 * <tr><td>SPR1753</td><td>Version 5</td><td>Automated Underwriting and Requirements Determination Should Detect Severe Errors for Both AC and Non - AC</td></tr>
 * <tr><td>SPR3063</td><td>Version 6</td><td>Underwriting Risk (APUWRSK) process error stops for Cyberlife cases in Wrappered mode</td></tr>
 * <tr><td>SPR3220</td><td>Version 7</td><td>Underwriting Risk Process Errors if Owner Specified Same as Insured on Application Entry</td></tr>
 * <tr><td>NBA213</td><td>Version 7</td><td>Unified User Interface</td></tr>
 * <tr><td>SPR3329</td><td>Version 7</td><td>Prevent erroneous "Retrieve variable name is invalid" messages from being generated by OINK</td></tr>
 * <tr><td>SPR3362</td><td>Version 7</td><td>Exceptions in Automated Processes and Logon Service Due to VP/MS Memory Leak</td></tr>
 * <tr><td>SPR3290</td><td>Version 7</td><td>General source code clean up during version 7</td></tr>
 * <tr><td>AXAL3.7.24</td><td>AXA Life Phase 1</td><td>Unadmitted Replacement Interface</td>
 * <tr><td>AXAL3.7.05</td><td>AXA Life Phase 1</td><td>Prior Insurance</td>
 * <tr><td>AXAL3.7.06</td><td>AXA Life Phase 1</td><td>Requirements Management</td>
 * <tr><td>AXAL3.7.21</td><td>AXA Life Phase 1</td><td>Prior Insurance Interface</td>
 * <tr><td>ALS4443</td><td>Broaden prior insurace HIT </td><td>Prior Insurance Interface</td>
 * <tr><td>QC 3019</td><td>AXA Life Phase 1</td><td>ALS4737 - Annuity should not be included in Pending + Inforce amount on Prior Insurance</td>
 * <tr><td>P2AXAL026</td><td>AXA Life Phase 2</td><td>UnderWriting Requirements</td></tr>
 * </table>
 * <p>
 * @author CSC FSG Developer
 * @version 7.0.0
 * @since New Business Accelerator - Version 4
 */

public class NbaUnderwritingRiskHelper {
	//NBA124 code deleted
	protected static NbaLogger logger = null;

	/**
	 * Return my <code>NbaLogger</code> implementation (e.g. NbaLogService).
	 * @return com.csc.fsg.nba.foundation.NbaLogger
	 */
	protected synchronized static NbaLogger getLogger() {
		if (logger == null) {
			try {
				logger = NbaLogFactory.getLogger(NbaUnderwritingRiskHelper.class.getName());
			} catch (Exception e) {
				NbaBootLogger.log("NbaUnderwritingRiskHelper could not get a logger from the factory.");
				e.printStackTrace(System.out);
			}
		}
		return logger;
	}

	//NBA124 code deleted

	/**
	 * Prepares the deOink map for underwriting risk calculation
	 * @param attachmentList List to be used to pass parameters to VPMS model
	 * @param deOink HashMap- Deoink map
	 * @param currentContractKey String contract key of current contract
	 * @throws NbaBaseException
	 */
	protected static void prepareDeOinkMap(List attachmentList, Map deOink, String currentContractKey) throws NbaBaseException {
		int policiesCount = (attachmentList == null) ? 0 : attachmentList.size();
		int totalCount = 0;
		NbaTXLife nbatxLife = null;
		Attachment tempAtt = null;
		Holding tempHolding = null;
		// SPR3290 code deleted
		try {
			for (int i = 0; i < policiesCount; i++) {
			    double maxBenefitAmount = 0;//P2AXAL026
			    tempAtt = (Attachment) attachmentList.get(i);
				if (tempAtt.isActionDeleteSuccessful()) { //ALS5497
					continue; //ALS5497
				} //ALS5497
				nbatxLife = new NbaTXLife(tempAtt.getAttachmentData().getPCDATA());
				//Begin AXAL3.7.05
				Relation matchRel = nbatxLife.getRelationForRelationRoleCode(NbaOliConstants.OLI_REL_HIT);
				if (matchRel == null) {
					matchRel = nbatxLife.getRelationForRelationRoleCode(NbaOliConstants.OLI_REL_TRY);
				}
				String roleCode = "0";
				if (matchRel != null) {
					roleCode = String.valueOf(matchRel.getRelationRoleCode());
				}
				//Begin ALS3084
				RelationExtension relExtension = NbaUtils.getFirstRelationExtension(matchRel);
				if (relExtension != null) {
					if (relExtension.getUWResolution() == NbaOliConstants.OLIX_UWRESOLUTIONTYPE_SAMEAS) {
						roleCode = String.valueOf(NbaOliConstants.OLI_REL_HIT);
					}
				}
				//End ALS3084
				//End AXAL3.7.05
				//begin NBA124
				if(nbatxLife.getOLifE().getHoldingCount() > 0){
					tempHolding = nbatxLife.getOLifE().getHoldingAt(0);
					//Ignore the current policy, it would get resolved through oink
					//ALS4340 Code Deleted
					 	LifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty lifeOrAnnuity =
							tempHolding.getPolicy().getLifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty();
						//Begin ALS4899	
						long informalAppApproval = 0;
						ApplicationInfoExtension appInfoExtension = NbaUtils.getFirstApplicationInfoExtension(tempHolding.getPolicy().getApplicationInfo());
						if (appInfoExtension != null) {
							informalAppApproval = appInfoExtension.getInformalAppApproval();
						}
						//End ALS4899
						
						if (lifeOrAnnuity != null && lifeOrAnnuity.isLife()) {
							Life life = lifeOrAnnuity.getLife();
							if (life != null) {
								Coverage coverage = null;
								ArrayList coverageList = life.getCoverage();
								int noOfCoverage = (coverageList == null) ? 0 : coverageList.size();
								Coverage baseCoverage = null; //ALS4940
								for (int j = 0; j < noOfCoverage; j++) {
									coverage = (Coverage) coverageList.get(j);
									boolean isADCCoverage = isADCBaseCoverage(coverage); // NBLXA-1510 ADC 152 Case should not include
									
									if (coverage.getIndicatorCode() == NbaOliConstants.OLI_COVIND_BASE) {
										baseCoverage = coverage;
										CovOption covOpt = nbatxLife.getCovOption(baseCoverage, NbaOliConstants.OLI_OPTTYPE_ROPR);//P2AXAL026
										maxBenefitAmount = covOpt != null ? covOpt.getMaxBenefitAmt() : 0;// P2AXAL026 // ALII1868
									}
									//End ALS4940
									// ALS4737 - Condition added for LifeCovTypeCode 
									if (coverage.getCurrentAmt() > 0 && coverage.getLifeCovTypeCode() != 53 && !isADCCoverage){	//AXAL3.7.05
										//Begin ALS4940
										Date effectiveDate = coverage.getEffDate();
										if (effectiveDate == null && coverage.getIndicatorCode() == NbaOliConstants.OLI_COVIND_RIDER) {
											effectiveDate = baseCoverage.getEffDate();
										}
										//End ALS4940
										if (totalCount == 0) {
											deOink.put("A_MAXBENEFITAMT",NbaObjectPrinter.localeUnformattedDecimal(maxBenefitAmount));//P2AXAL026
											deOink.put("A_FACEAMT", NbaObjectPrinter.localeUnformattedDecimal(coverage.getCurrentAmt()));	//SPR2149 ALS4340
											deOink.put("A_PRODUCTTYPE", String.valueOf(tempHolding.getPolicy().getProductType())); //ALS4340
											deOink.put("A_POLICYSTATUS", String.valueOf(tempHolding.getPolicy().getPolicyStatus())); //ALS4340
											if (tempHolding.getPolicy().getApplicationInfo() != null) {
												deOink.put("A_ALTERNATEIND", String.valueOf(tempHolding.getPolicy().getApplicationInfo().getAlternateInd())); //ALS4340
												deOink.put("A_ADDITIONALIND", String.valueOf(tempHolding.getPolicy().getApplicationInfo().getAdditionalInd())); //ALS4340
												deOink.put("A_APPTYPE", String.valueOf(tempHolding.getPolicy().getApplicationInfo()
														.getApplicationType())); //ALS5093 ALS4340
											} else {
												deOink.put("A_ALTERNATEIND", String.valueOf(false)); //ALS4340
												deOink.put("A_ADDITIONALIND", String.valueOf(false)); //ALS4340
												deOink.put("A_APPTYPE", ""); //ALS5093 ALS4340
											}
											//Begin ALS4340
											deOink.put("A_CARRIERCODE", String.valueOf(tempHolding.getPolicy().getCarrierCode()));
											deOink.put("A_POLICYNUMBER", String.valueOf(tempHolding.getPolicy().getPolNumber()));
											deOink.put("A_POLICYEFFDATE", NbaUtils.getStringFromDate(effectiveDate));//ALS4341 ALS4940
											deOink.put("A_CONTRACTMATCH", roleCode); //AXAL3.7.05
											deOink.put("A_TRANSTYPE", String.valueOf(nbatxLife.getTransType())); //AXAL3.7.05
											deOink.put("A_INDICATORCODE", String.valueOf(coverage.getIndicatorCode())); //ALPC079
											deOink.put("A_LIVESTYPE", String.valueOf(coverage.getLivesType())); //ALPC079
											deOink.put("A_LIFECOVTYPECODE", String.valueOf(coverage.getLifeCovTypeCode())); //ALPC079
											deOink.put("A_PRODUCTCODE", String.valueOf(coverage.getProductCode())); //ALPC079
											deOink.put("A_INFORMALAPPAPPROVAL", String.valueOf(informalAppApproval)); //ALS4899
											//End ALS4340
										} else {
											if (coverage.getIndicatorCode() == NbaOliConstants.OLI_COVIND_BASE) { //ALII1654
												deOink.put("A_MAXBENEFITAMT[" + totalCount + "]",NbaObjectPrinter.localeUnformattedDecimal(maxBenefitAmount));//P2AXAL026, ALII1654
											} else {
												deOink.put("A_MAXBENEFITAMT[" + totalCount + "]","0"); // ALII1654
											}
											deOink.put("A_FACEAMT[" + totalCount + "]", NbaObjectPrinter.localeUnformattedDecimal(coverage.getCurrentAmt())); //SPR2149 ALS4340
											deOink.put("A_PRODUCTTYPE[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getProductType())); //ALS4340
											deOink.put("A_POLICYSTATUS[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getPolicyStatus())); //ALS4340
											if (tempHolding.getPolicy().getApplicationInfo() != null) {
												deOink.put("A_ALTERNATEIND[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getApplicationInfo().getAlternateInd())); //ALS4340
												deOink.put("A_ADDITIONALIND[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getApplicationInfo().getAdditionalInd())); //ALS4340
												deOink.put("A_APPTYPE[" + totalCount + "]", String.valueOf(tempHolding.getPolicy()
														.getApplicationInfo().getApplicationType())); //ALS5093 ALS4340
											} else {
												deOink.put("A_ALTERNATEIND[" + totalCount + "]", String.valueOf(false)); //ALS4340
												deOink.put("A_ADDITIONALIND[" + totalCount + "]", String.valueOf(false)); //ALS4340
												deOink.put("A_APPTYPE[" + totalCount + "]", ""); //ALS5093 ALS4340
											}
											//Begin ALS4340
											deOink.put("A_CARRIERCODE[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getCarrierCode()));
											deOink.put("A_POLICYNUMBER[" + totalCount + "]", String.valueOf(tempHolding.getPolicy().getPolNumber()));
											deOink.put("A_POLICYEFFDATE[" + totalCount + "]", NbaUtils.getStringFromDate(effectiveDate));//ALS4341 ALS4940
											deOink.put("A_CONTRACTMATCH[" + totalCount + "]", roleCode); //AXAL3.7.05
											deOink.put("A_TRANSTYPE[" + totalCount + "]", String.valueOf(nbatxLife.getTransType())); //AXAL3.7.05
											deOink.put("A_INDICATORCODE[" + totalCount + "]", String.valueOf(coverage.getIndicatorCode())); //ALPC079
											deOink.put("A_LIVESTYPE[" + totalCount + "]", String.valueOf(coverage.getLivesType())); //ALPC079
											deOink.put("A_LIFECOVTYPECODE[" + totalCount + "]", String.valueOf(coverage.getLifeCovTypeCode())); //ALPC079
											deOink.put("A_PRODUCTCODE[" + totalCount + "]", String.valueOf(coverage.getProductCode())); //ALPC079
											deOink.put("A_INFORMALAPPAPPROVAL[" + totalCount + "]", String.valueOf(informalAppApproval)); //ALS4899
											//ALS4340
										}
										totalCount++;
									}	//AXAL3.7.05
								
								}
								
							}
							
						}
					//ALS4340 Code Deleted
				
				}//end NBA124
			}
			deOink.put("A_NumberOfContracts", String.valueOf(totalCount));
		} catch (Exception e) {
			NbaBaseException nbe = new NbaBaseException(e);
			throw nbe;
		}
	}

	

	//NBA124 code deleted

	/**
	 * Creates and adds attachment to a list.
	 * @param attachmentList List of attachemnt to which attachment is to be added
	 * @param attachmentNbaTXLife NbaTXLife to be added as attachment
	 * @param nbaOlifeId NbaOLifEId object used to set the Id of attachment
	 * @param attachmentType AttachmentType to set
	 */
	//NBA124 changed method signature, renamed method. Added static modifier
	//AXAL3.7.05 Modified method signature
	protected static void addAttachment(List attachmentList, NbaTXLife attachmentNbaTXLife, NbaOLifEId nbaOlifeId, long attachmentType) {
		Attachment attachment = new Attachment();
		nbaOlifeId.setId(attachment);
		attachment.setAttachmentBasicType(NbaOliConstants.OLI_LU_BASICATTMNTTY_TEXT); //NBA124
		attachment.setAttachmentType(attachmentType); //AXAL3.7.24 AXAL3.7.05
		AttachmentData attData = new AttachmentData();
		attData.setPCDATA(attachmentNbaTXLife.toXmlString());
		attachment.setAttachmentData(attData);
		attachment.setDateCreated(new Date()); //NBA124
		attData.setActionAdd();
		attachment.setActionAdd();
		attachmentList.add(attachment);
	}

	/**
	 * Invokes the Underwriting Risk VPMS model to calculate Total Pending,Total Inforce,
	 * Highest Alternate,Total Additional and Total Pending & Inforce     
	 * @param nbaTxLife Holding Inquiry
	 * @param deOink Holds VPMS attributes and their value.
	 * @param work workitem being processed
	 * @param NbaUserVO userVO representing the current user
	 * @param modelName String representing the model name to be executed to calculate the risk
	 * @return an instance of NbaVpmsUnderwritingRiskData
	 * @throws NbaBaseException
	 */
	//NBA124 added static modifier
	protected static NbaVpmsUnderwritingRiskData getDataFromVpmsModelAutoUnderwriting(NbaTXLife nbaTxLife, Map deOink, NbaDst work, NbaUserVO userVO,String modelName)
		throws NbaBaseException {
	    NbaVpmsUnderwritingRiskData data = null; //SPR3362
	    NbaVpmsAdaptor vpmsProxy = null; //SPR3362
	    NbaOinkRequest oinkRequest = new NbaOinkRequest();
		NbaOinkDataAccess oinkData = new NbaOinkDataAccess(work.getNbaLob()); //NBA124
		oinkData.setContractSource(nbaTxLife);
		oinkData.setAcdbSource(new NbaAcdb(), nbaTxLife);//SPR3329
		//NBA124 code deleted
		try { //SPR3362
            vpmsProxy = new NbaVpmsAdaptor(oinkData, modelName);//SPR3362
            vpmsProxy.setVpmsEntryPoint("P_GetTotals");
            vpmsProxy.setSkipAttributesMap(deOink);
            vpmsProxy.setANbaOinkRequest(oinkRequest);
            data = new NbaVpmsUnderwritingRiskData(vpmsProxy.getResults()); //SPR3362
            //SPR3362 code deleted
        } catch (java.rmi.RemoteException re) {
			throw new NbaBaseException("Autounderwriting problem", re);
		} finally {
		//begin SPR3362
			try {
			    if(vpmsProxy != null){
			        vpmsProxy.remove();
			    }
			} catch (RemoteException e) {
				getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
			}
		}
		return data; 
		//end SPR3362
	}

	/**
	 * Invokes the Client search VPMS model to determine the search criteria to be used for 
	 * party inquiry.
	 * @param nbaTxLife Holding Inquiry
	 * @param work NbaDst Dst object representing the workitem
	 * @param workType String representing the party type.
	 * @param primaryOrSecondry  String representing whether to get primary or secondry search criteria from VPMS
	 * @param configCategory String specifies the configuration category
	 * @return An instance of NbaVpmsPartyInquiryRequestData
	 * @throws NbaBaseException
	 */
	//NBA124 added static modifier
	protected static NbaVpmsPartyInquiryRequestData getDataFromVpmsModelClientSearch(
		NbaTXLife nbaTxLife,
		NbaDst work,
		String partyType,
		String primaryOrSecondry,
		String configCategory)
		throws NbaBaseException {
	    NbaVpmsPartyInquiryRequestData data = null; //SPR3362
		// SPR3290 code deleted
		NbaOinkDataAccess oinkData = new NbaOinkDataAccess();
		oinkData.setContractSource(nbaTxLife);
		oinkData.setLobSource(work.getNbaLob());
		Map deOink = new HashMap(4, 1);
		deOink.put(NbaVpmsConstants.A_PARTY_TYPE, partyType);
		deOink.put(NbaVpmsConstants.A_CUSTOMER_REF_CLIENT_SYSTEM, configCategory);
		deOink.put(NbaVpmsConstants.A_PRIMARY_OR_SECONDARY, primaryOrSecondry);
		NbaVpmsAdaptor vpmsProxy = null; //SPR3362
		try { //SPR3362
            vpmsProxy = new NbaVpmsAdaptor(oinkData, NbaVpmsAdaptor.CLIENT_SEARCH); //SPR3362
            vpmsProxy.setVpmsEntryPoint(NbaVpmsAdaptor.EP_GET_PARTY_INQUIRY_SEARCH_KEYS);
            vpmsProxy.setSkipAttributesMap(deOink);
            data = new NbaVpmsPartyInquiryRequestData(vpmsProxy.getResults()); //SPR3362
            //SPR3362 code deleted
        } catch (java.rmi.RemoteException re) {
			throw new NbaBaseException("Problem in getting result from client search model.", re);
		} finally {
		//begin SPR3362
			try {
			    if(vpmsProxy != null){
			        vpmsProxy.remove();
			    }
			} catch (RemoteException e) {
				getLogger().logError(NbaBaseException.VPMS_REMOVAL_FAILED);
			}
		}
		return data; 
		//end SPR3362
	}

	/**
	 * Adds risk to a given party
	 * @param party Party to which risk and attachments are to be added
	 * @param data NbaVpmsUnderwritingRiskData represent undewriting risk for the incoming party. This information is used to populate Party.Risk object.
	 */
	//NBA124 changed method signature, renamed method and removed parameter List attachmentList. Added static modifier
	protected static void addRiskToParty(Party party, NbaVpmsUnderwritingRiskData data) {
		Risk risk = party.getRisk();
		if (risk == null) {
			risk = new Risk();
			risk.setActionAdd();
			party.setRisk(risk);
		}
		if (getLogger().isDebugEnabled()) {
			getLogger().logDebug(" Total Inforce and Applied = " + data.getTotalInforceAndApplied());
			getLogger().logDebug(" Total Pending = " + data.getTotalPending());
			getLogger().logDebug(" Total Inforce = " + data.getTotalInforce());
			getLogger().logDebug(" Highest Alternate =  " + data.getHighestAlternate());
		}
		
		//Set Risk.TotalInforceAndAppliedIns to set TotalAmountAtRisk
		risk.setTotalInforceAndAppliedIns(data.getTotalAmtAtRisk()); //ALS4744
		OLifEExtension olifeExt = null;
		RiskExtension riskExtension = NbaUtils.getFirstRiskExtension(risk);
		if (riskExtension == null) {
			olifeExt = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_RISK);
			risk.addOLifEExtension(olifeExt);
			riskExtension = NbaUtils.getFirstRiskExtension(risk);
			olifeExt.setActionAdd();
		}
		//Set RskExtension.TotalInforceAndAppliedIns to set Pending+Inforce amount
		riskExtension.setTotalInforceAndAppliedIns(data.getTotalInforceAndApplied()); //ALS4744
		riskExtension.setTotalPending(data.getTotalPending());
		riskExtension.setTotalAdditional(data.getTotalAdditional());
		riskExtension.setTotalInforce(data.getTotalInforce());
		riskExtension.setHighestAlternate(data.getHighestAlternate());
		riskExtension.setActionUpdate();
		risk.setActionUpdate();
		party.setActionUpdate();

	}
	/**
	 * Does a holding inquiry on pending database for the passed in contractkey. 
	 * @param contractKey Contract key to be used for holding inquiry 
	 * @param backendKey
	 * @param work Current Work object
	 * @param userVO NbaUserVO representing the current User.
	 * @return An instance of NbaTXLife containing holding inquiry response
	 * @throws NbaBaseException
	 */
	 //NBA124 changed method scope
    //QC4373 APSL178 P2AXAL013 changed method signature
	protected static NbaTXLife doHoldingInquiry(String contractKey, String companyCode, String backendKey, NbaDst work, NbaUserVO userVO) throws NbaBaseException {  
		NbaTXLife nbaTXLife = null;
		try {
			//NBA213 deleted code
			NbaTXRequestVO nbaTXRequest = new NbaTXRequestVO();
			nbaTXRequest.setAccessIntent(NbaConstants.READ);
			nbaTXRequest.setTransType(NbaOliConstants.TC_TYPE_HOLDINGINQ);
			nbaTXRequest.setTransMode(NbaOliConstants.TC_MODE_ORIGINAL);
			nbaTXRequest.setBusinessProcess(NbaUtils.getBusinessProcessId(userVO)); //SPR2639
			nbaTXRequest.setNbaLob(work.getNbaLob());
			// SPR3290 code deleted
			//create txlife with default request fields
			NbaTXLife nbaTXLifeRequest = new NbaTXLife(nbaTXRequest);
			nbaTXLifeRequest.getPrimaryHolding().getPolicy().setPolNumber(contractKey);
			nbaTXLifeRequest.getPrimaryHolding().getPolicy().setCarrierCode(companyCode);//QC4373 APSL178
		   	nbaTXLifeRequest.getOLifE().getSourceInfo().setFileControlID(backendKey);//P2AXAL013
		  	nbaTXLife = com.csc.fsg.nba.access.contract.NbaContractAccess.doContractInquiry(nbaTXLifeRequest, userVO, work.getNbaLob());  //NBA213 QC4373 APSL178 Method Sign
			return nbaTXLife;
		} catch (Exception e) {
			throw new NbaBaseException(e);
		}
	}

	/** Creates NbaTXLife  object, which is attached with the party for the underwriting risk. 
	 *  It takes in the input the whole NbaTXLife and then filters it out to a new NbaTXLife to contain the information 
	 *  which is pertaining to then incoming party object. 
	 *  
	 * @param  srcNbaTXLife the NbaTXLife object containing the holding which is to be filtered
	 * @param  srcParty party object used to filter the holding
	 * @return returns the filtered NbaTXLife object. 
	 */
	//NBA124 changed method signature, added NbaOLifEId nbaOLifEId. Added static modifier , ALII1869 modified signature
	public static NbaTXLife prepareNbaTXLifeForAttachment(NbaTXLife srcNbaTXLife, Party srcParty, NbaOLifEId nbaOLifEId,NbaDst work) {
		if(srcNbaTXLife.isAnnuity()){//Bypass annuities
			return null;
		}
		//begin NBA124
		NbaTXRequestVO nbaTXRequest = new NbaTXRequestVO();
		nbaTXRequest.setBusinessProcess(srcNbaTXLife.getBusinessProcess());
		nbaTXRequest.setNbaLob(work.getNbaLob()); //ALII1869
		NbaTXLife attachmentNbaTXLife = new NbaTXLife(nbaTXRequest);
		if (nbaOLifEId == null) {
			nbaOLifEId = new NbaOLifEId(attachmentNbaTXLife);
		} 
		//add a party object to attachmentNbaTXLife   
		String matchedPartyID = addParty(srcParty, srcNbaTXLife, attachmentNbaTXLife, nbaOLifEId);
		//add a holding object to attachmentNbaTXLife
		addHoldingInfo(srcNbaTXLife, attachmentNbaTXLife, nbaOLifEId);
		//set coverage information
		setCoverageInformation(srcNbaTXLife.getPolicy(), attachmentNbaTXLife.getPolicy(), matchedPartyID);
		if(matchedPartyID != null){
			addRelation(srcNbaTXLife, attachmentNbaTXLife, nbaOLifEId);
		}
		//end NBA124
		return attachmentNbaTXLife;
	}

	/** Updates coverage information to a destination coverage from a source coverage. It updates only the fields which are used
	 *  in underwriting risk calculation 
	 *  
	 * @param  srcCoverage source Coverage object
	 * @param  destCoverage destination coverage object
	 * @param  lifePar LifeParticipant Object to be attached to the destination Coverage object
	 * 
	 */
	//NBA124 added static modifier
	protected static void updateCoverageInformation(Coverage srcCoverage, Coverage destCoverage, LifeParticipant lifePar) {
		destCoverage.setId(srcCoverage.getId());
		destCoverage.setCoverageKey(srcCoverage.getCoverageKey());
		destCoverage.setProductCode(srcCoverage.getProductCode());
		destCoverage.setLifeCovTypeCode(srcCoverage.getLifeCovTypeCode());
		//Begin ALS4340
		if (lifePar.getLifeParticipantRoleCode() == NbaOliConstants.OLI_PARTICROLE_PRIMARY) {
			destCoverage.setIndicatorCode(srcCoverage.getIndicatorCode());
			//Begin ALS3159
			if (NbaUtils.isCTIRCoverage(srcCoverage)) {
				lifePar.setLifeParticipantRoleCode(NbaOliConstants.OLI_PARTICROLE_CHILD);
			}
			//End ALS3159
		} else {
			destCoverage.setIndicatorCode(NbaOliConstants.OLI_COVIND_BASE);
		}
		//End ALS4340
		destCoverage.setLivesType(srcCoverage.getLivesType());
		destCoverage.setDeathBenefitOptType(srcCoverage.getDeathBenefitOptType());
		destCoverage.setCurrentAmt(srcCoverage.getCurrentAmt());
		destCoverage.setEffDate(srcCoverage.getEffDate());
		destCoverage.setTermDate(srcCoverage.getTermDate());
		destCoverage.setCovOption(srcCoverage.getCovOption());//Code Deleted P2AXAL026
		destCoverage.addLifeParticipant(lifePar);
		CoverageExtension srcCovExt = NbaUtils.getFirstCoverageExtension(srcCoverage);
		if (srcCovExt != null) {
			CoverageExtension destCovExt = NbaUtils.getFirstCoverageExtension(destCoverage);
			if (destCovExt == null) {
				OLifEExtension olifeExt = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_COVERAGE);
				destCoverage.addOLifEExtension(olifeExt);
				destCovExt = olifeExt.getCoverageExtension();
			}
			destCovExt.setUnitTypeInd(srcCovExt.getUnitTypeInd());
			destCovExt.setRateClass(srcCovExt.getRateClass());

		}
	}
	

	/** Compares two parties and returns true if both are same by matching some subset of information from (FirstName,LastName,GovtID,BirthDate,BirthState)
	 * The subset is decided by the presence of this information in the srcParty object i.e if srcParty contains lastName
	 * it would be considered while matching the party . Other fields like LastName,GovtId etc are processed in a similar fashion.
	 *  
	 * @param  srcParty source Party object
	 * @param  destCoverage destination coverage object
	 * @return boolean returns true if destParty is fouund same as srcParty 
	 */
	//NBA124 added static modifier
	protected static boolean compareParty(Party srcParty, Party destParty) {
		Person srcPerson = srcParty.getPersonOrOrganization().getPerson();
		Person destPerson = destParty.getPersonOrOrganization().getPerson();
		//If sourceParty contains last name then consider it to be matched
		if (srcPerson.hasLastName() && !srcPerson.getLastName().equalsIgnoreCase(destPerson.getLastName())) {
			return false;
		}
		//ALPC240 Code Deleted
		if (srcPerson.hasFirstName() && !srcPerson.getFirstName().equalsIgnoreCase(destPerson.getFirstName())) {
			return false;
		}
		if (srcPerson.hasBirthDate() && !(destPerson.hasBirthDate() && srcPerson.getBirthDate().compareTo(destPerson.getBirthDate()) == 0)) { //SPR3220
			return false;
		}
		//ALPC240 Code Deleted
		if (srcParty.hasGovtID() && !(srcParty.getGovtID().equalsIgnoreCase(destParty.getGovtID())||destParty.getGovtID()==null)) {//ALS4443
			return false;
		}
		if (srcParty.hasPartyTypeCode() && !(srcParty.getPartyTypeCode() == destParty.getPartyTypeCode())) {
			return false;
		}
		//ALPC240 Code Deleted
		//If all things are matched then return true
		return true;
	}

	/** Updates party information to a destination party from a source party. It updates only the fields which are used
	 *  in underwriting risk calculation 
	 *  
	 * @param  srcParty source Party object
	 * @param  destParty destination Party object
	 */
	//NBA124 added static modifier
	protected static void updatePartyInformation(Party srcParty, Party destParty) {
		// SPR3290 code deleted
		PersonOrOrganization personOrOrganization = null;
		PersonOrOrganization newPersonOrOrganization = null;
		Person person = null;
		Person newPerson = null;
		personOrOrganization = srcParty.getPersonOrOrganization();
		destParty.setId(srcParty.getId());
		person = personOrOrganization.getPerson();
		if (person != null) {
			newPerson = new Person();
			newPerson.setFirstName(person.getFirstName());
			newPerson.setMiddleName(person.getMiddleName());
			newPerson.setLastName(person.getLastName());
			newPerson.setBirthDate(person.getBirthDate());
			newPerson.setSmokerStat(person.getSmokerStat());
			PersonExtension existingPersonExtension = NbaUtils.getFirstPersonExtension(person);
			if (existingPersonExtension != null) {
				OLifEExtension olifeExt = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_PERSON);
				newPerson.addOLifEExtension(olifeExt);
				PersonExtension personExtension = NbaUtils.getFirstPersonExtension(newPerson);
				personExtension.setRateClass(existingPersonExtension.getRateClass());
			}
		}
		newPersonOrOrganization = new PersonOrOrganization();
		newPersonOrOrganization.setPerson(newPerson);
		destParty.setPersonOrOrganization(newPersonOrOrganization);
	}
	
	
	/**
	 * Adds a holding object to new contract XML. The <code>Holding</code> object contains information from holding inquiry (Tx203) of that contract
	 * @param origContract orignal holding inquiry
	 * @param newContract newly constructed contract XML
	 * @param nbaOLifEId olife ID generator
	 */
	//NBA124 New Method, ALII1869 modified
	protected static void addHoldingInfo(NbaTXLife origContract, NbaTXLife newContract, NbaOLifEId nbaOLifEId) {
		Policy newPolicy = newContract.getPolicy();
		Policy origPolicy = origContract.getPolicy();

		//Set Policy Information
		nbaOLifEId.setId(newPolicy);
		if (newContract.getOLifE().getPartyCount() > 0){
			newPolicy.setCarrierPartyID(newContract.getOLifE().getPartyAt(0).getId());
		}
		newPolicy.setPolNumber(origPolicy.getPolNumber());
		newPolicy.setPolicyStatus(origPolicy.getPolicyStatus());
		newPolicy.setProductType(origPolicy.getProductType());
		newPolicy.setCarrierCode(origPolicy.getCarrierCode());
		if (origPolicy.hasIssueType()) { //SR564247 ALII1671
			newPolicy.setIssueType(origPolicy.getIssueType()); 
		}
		PolicyExtension polExt = NbaUtils.getFirstPolicyExtension(newPolicy);
		if (polExt == null) {
			OLifEExtension oLifeExt = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_POLICY);
			newPolicy.addOLifEExtension(oLifeExt);
			polExt = oLifeExt.getPolicyExtension();
		}
		polExt.setPendingContractStatus(origContract.getPrimaryContractStatus());

		newPolicy.setRatedInd(origPolicy.getRatedInd());
		newPolicy.setCarrierAdminSystem(origPolicy.getCarrierAdminSystem()); //NBLXA-2274
		newPolicy.setCarrierCode(origPolicy.getCarrierCode());
		newPolicy.setApplicationInfo(new ApplicationInfo());
		newPolicy.getApplicationInfo().setAdditionalInd(origPolicy.getApplicationInfo().getAdditionalInd());
		newPolicy.getApplicationInfo().setAlternateInd(origPolicy.getApplicationInfo().getAlternateInd());
		newPolicy.getApplicationInfo().setApplicationType(origPolicy.getApplicationInfo().getApplicationType()); //ALS5093
		//Begin ALS4899
		ApplicationInfoExtension origAppInfoExtension = NbaUtils.getFirstApplicationInfoExtension(origPolicy.getApplicationInfo());
		if (origAppInfoExtension != null) {
			OLifEExtension appInfoOLifeExt = NbaTXLife.createOLifEExtension(NbaOliConstants.EXTCODE_APPLICATIONINFO);
			newPolicy.getApplicationInfo().addOLifEExtension(appInfoOLifeExt);
			appInfoOLifeExt.getApplicationInfoExtension().setInformalAppApproval(origAppInfoExtension.getInformalAppApproval());
			origAppInfoExtension.setTermConvPurchOptInd(origAppInfoExtension.getTermConvPurchOptInd());//P2AXAL026
		}
		//End ALS4899
	}
	
	
	/**
	 * Add a party object on the newly created NbaTXLife object. Performs a search on original contract to look for a party that matches 
	 * information on the requesting party. Use the matched party as a base to populate newly created party object
	 * Also return the matched party object ID of original contract for further reference purpose. 
	 * @param requestParty requesting party for which risk calculation is getting performed.
	 * @param origContract a complete holding inquiry of the matching contract number obtained from party inquiry service  
	 * @param newContract an instance of <code>NbaTXLife</code> which contains minimal information return for matching contract   
	 * @return ID of a party matched on holding inquiry of the contract.
	 */
	//NBA124 New Method
	protected static String addParty(Party requestParty, NbaTXLife origContract, NbaTXLife newContract, NbaOLifEId nbaOLifEId) {
		String partyId = null;
//		OLifE origOlife = origContract.getOLifE();
		List partyList = origContract.getInsurableParties();
		Iterator partyIterator = partyList.iterator();
		Party currentParty = null;
		Party newParty = null;
		while (partyIterator.hasNext()) {
			currentParty = (Party) partyIterator.next();
			if (currentParty.hasPersonOrOrganization() == false || currentParty.getPersonOrOrganization().isPerson() == false) {  //SPR3063
				continue;
			}
			if (compareParty(requestParty, currentParty)) {
				newParty = new Party();
				nbaOLifEId.setId(newParty); //assign ID to the new party object created.
				updatePartyInformation(currentParty, newParty); //Update newParty Object
				newContract.getOLifE().addParty(newParty);
				partyId = currentParty.getId(); //remember matched party of original contract for later usage
				break;
			}
		}

		return partyId;
	}
	
	
	/**
	 * Set coverage information from holding inquiry to newly created contract XML. 
	 * Use machedPartyID to identify the coverages to be included 
	 * @param origPolicy policy object from holding inquiry
	 * @param newPolicy policy object from newly created contract
	 * @param matchedPartyID the party ID to match coverges
	 */
	//NBA124 New Method
	protected static void setCoverageInformation(Policy origPolicy, Policy newPolicy, String matchedPartyID) {
		LifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty origLifeOrAnnObj = origPolicy.getLifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty();
		Life origLife = origLifeOrAnnObj.getLife();
		LifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty newLifeOrAnnObj = new LifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty();
		Life newLife = new Life();
		newLifeOrAnnObj.setLife(newLife);
		newPolicy.setLifeOrAnnuityOrDisabilityHealthOrPropertyandCasualty(newLifeOrAnnObj);
		if (matchedPartyID != null) {
			// SPR3290 code deleted
			List coverages = origLife.getCoverage();
			ListIterator covIterator = coverages.listIterator();
			Coverage coverage = null;
			while (covIterator.hasNext()) {
				coverage = (Coverage) covIterator.next();
				List lifeParticipants = coverage.getLifeParticipant();
				ListIterator lifeParIterator = lifeParticipants.listIterator();
				LifeParticipant lifeParticipant = null;
				while (lifeParIterator.hasNext()) {
					lifeParticipant = (LifeParticipant) lifeParIterator.next();
					if (matchedPartyID.equalsIgnoreCase(lifeParticipant.getPartyID())) {
						Coverage newCoverage = new Coverage();
						updateCoverageInformation(coverage, newCoverage, lifeParticipant);
						newLife.addCoverage(newCoverage);
						break;
					}
				}
			}
		}
	}
	
	/**
	 * Add attachments to party 
	 * @param party
	 * @param attachmentList
	 * @param attachmentType
	 */
	//NBA124 New Method
	//AXAL3.7.05 Modified method signature
	protected static void addAttachmentToParty(Party party, List attachmentList, long attachmentType){
		List existingAttachments = party.getAttachment();
		if (existingAttachments == null) {
			existingAttachments = new ArrayList();
		}
		int delCount = existingAttachments.size();
		for (int i = 0; i < delCount; i++) {
			//begin AXAL3.7.05
			Attachment attachment = (Attachment) existingAttachments.get(i);
			if (attachment.getAttachmentType() == attachmentType) {
				attachment.setActionDelete();
			}
			//end AXAL3.7.05
		}
		existingAttachments.addAll(attachmentList);
		party.setAttachment((ArrayList) existingAttachments);
	}
	
   /** 
    * Adds a relation to new contract XML relating holding and party
	* @param origContract
	* @param newContract
	* @param nbaOLifEId
	*/
   //NBA124 New Method
   protected static void addRelation(NbaTXLife origContract, NbaTXLife newContract, NbaOLifEId nbaOLifEId) {
	   Relation relation = new Relation();
	   nbaOLifEId.setId(relation);
	   relation.setRelatedObjectID(newContract.getOLifE().getPartyAt(0).getId());
	   relation.setOriginatingObjectID(newContract.getOLifE().getHoldingAt(0).getId());
	   relation.setOriginatingObjectType(NbaOliConstants.OLI_HOLDING);
	   relation.setRelatedObjectType(NbaOliConstants.OLI_PARTY);
   }
   
   /**
	* Check the party object to make sure that it contains suffcient data required by passed search criteria.
	* Return true if it does, false otherwise.
	* @param party party to be verified
	* @param searchCriteria search criteria
	* @return true if party object contains minimum search data, false otherwise.
	*/
   //SPR2743 New Method
   protected static boolean hasMinimumSearchData(Party party, NbaVpmsPartyInquiryRequestData searchCriteria) {
	   boolean hasMinSearchData = true;
	   PersonOrOrganization personOrOrg = party.getPersonOrOrganization();
	   if (personOrOrg != null && personOrOrg.isPerson()) {
		   Person person = personOrOrg.getPerson();
		   if ((searchCriteria.getLastName() && (!person.hasLastName()))
			   || (searchCriteria.getFirstName() && (!person.hasFirstName()))
			   || (searchCriteria.getMiddleName() && (!person.hasMiddleName()))
			   || (searchCriteria.getBirthDate() && (!person.hasBirthDate()))
			   || (searchCriteria.getBirthState() && (!person.hasBirthJurisdictionTC()))
			   || (searchCriteria.getGovtID() && (!party.hasGovtID()))
			   || (searchCriteria.getPartyTypeCode() && (!party.hasPartyTypeCode()))
			   || (searchCriteria.getPartyKey() && (!party.hasPartyKey())))
			   hasMinSearchData = false;
	   }
	   return hasMinSearchData;
   }
   
   /**
	* Determines if there are any totals available in passed 
	* @param data
	* @return
	*/
   //SPR1753 Nwe Method
	protected static boolean hasTotals(NbaVpmsUnderwritingRiskData data) {
		return (
			data.hasHighestAlternate()
				|| data.hasTotalAdditional()
				|| data.hasTotalInforce()
				|| data.hasTotalInforceAndApplied()
				|| data.hasTotalPending());
	}
	/**
	 * This method creates a LifeParticipant object corresponding to given 'partyId' and adds it to given 'coverage'.
	 * @param olifeId
	 * @param partyId
	 * @param coverage
	 * @param relationRoleCode
	 * @return
	 */
	//AXAL3.7.21 New Method
	protected static void addCoverageLifeParticipant(NbaOLifEId olifeId, String partyId, Coverage coverage, long relationRoleCode) {
		if (partyId == null) {
			return;
		}
		long lifeParticipantRoleCode = getLifeParticipantRoleCode(relationRoleCode);
		int noOfLifeParticipants = coverage.getLifeParticipantCount();
		LifeParticipant participant = null;
		for (int i = 0; i < noOfLifeParticipants; i++) {
			participant = coverage.getLifeParticipantAt(i);
			if (partyId.equalsIgnoreCase(participant.getPartyID())) {
				return;
			}
		}
		participant = new LifeParticipant();
		olifeId.setId(participant);
		participant.setActionAdd();
		participant.setLifeParticipantRoleCode(lifeParticipantRoleCode);
		participant.setPartyID(partyId);
		coverage.addLifeParticipant(participant);
	}
	/**
	 * This method returns LifeParticipantRoleCode corresponding to the given RelationRoleCode.
	 * @param relationRoleCode
	 * @return
	 */
	//AXAL3.7.21 New Method
	protected static long getLifeParticipantRoleCode(long relationRoleCode) {
		if (relationRoleCode == NbaOliConstants.OLI_REL_INSURED) {
			return NbaOliConstants.OLI_PARTICROLE_PRIMARY;
		} else if (relationRoleCode == NbaOliConstants.OLI_REL_JOINTINSURED) {
			return NbaOliConstants.OLI_PARTICROLE_JOINT;
		} else if (relationRoleCode == NbaOliConstants.OLI_REL_SPOUSE) {
			return NbaOliConstants.OLI_PARTICROLE_SPOUSE;
		} else if (relationRoleCode == NbaOliConstants.OLI_REL_DEPENDENT) {
			return NbaOliConstants.OLI_PARTICROLE_DEP;
		}
		
		return NbaOliConstants.OLI_PARTICROLE_OTHINSURED;
	}
	
	
	//NBLXA-1467 NBLXA-188
	protected static void prepareDeOinkMapForGIApplication(List attachmentList, Map deOink, String currentContractKey) throws NbaBaseException {
		List giAttachmentList = new ArrayList();
		NbaTXLife nbatxLife = null;
		Attachment tempAtt = null;
		Iterator itr = attachmentList.iterator();
		try {
			while (itr.hasNext()) {
				tempAtt = (Attachment) itr.next();
				nbatxLife = new NbaTXLife(tempAtt.getAttachmentData().getPCDATA());
				if (NbaUtils.isGIApplication(nbatxLife)) {
					giAttachmentList.add(tempAtt);
				}
			}
			prepareDeOinkMap(giAttachmentList, deOink, currentContractKey);
		} catch (Exception e) {
			NbaBaseException nbe = new NbaBaseException(e);
			throw nbe;
		}
	}
	
	// NBLXA-1510 ADC 152 Case should not include
	protected static boolean isADCBaseCoverage(Coverage coverage) {
		if (coverage != null
				&& coverage.getIndicatorCode() == NbaOliConstants.OLI_COVIND_BASE
				&& coverage.getProductCode() != null
				&& (coverage.getProductCode().equalsIgnoreCase(NbaConstants.PROD_ADC_152) || coverage.getProductCode().equalsIgnoreCase(
						NbaConstants.PRODCODE_ADC))) {
			return true;
		}
		return false;
	}
}
