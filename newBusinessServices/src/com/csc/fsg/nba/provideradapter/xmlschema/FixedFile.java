/*
 * DO NOT EDIT!
 *
 * This file was generated by the Breeze XML Studio code generator.
 *
 *        Project: file:/N:/NBA/Version2/nba/Development/Providers/OR01.xsd Binding
 *     Class Name: FixedFile
 *           Date: Thu Nov 21 11:38:59 CST 2002
 * Breeze Version: 3.0.0 build 382
 *
 * IMPORTANT: Please see your Breeze license for more information on
 *            where and how this generated code may be used.
 *
 */

package com.csc.fsg.nba.provideradapter.xmlschema;


import java.io.InputStream;
import java.io.OutputStream;

import com.tbf.xml.FormattedOutputStream;
import com.tbf.xml.Validateable;
import com.tbf.xml.XmlAttributeList;
import com.tbf.xml.XmlElement;
import com.tbf.xml.XmlIntegerValidator;
import com.tbf.xml.XmlNamespaceManager;
import com.tbf.xml.XmlObject;
import com.tbf.xml.XmlOutputStream;
import com.tbf.xml.XmlValidationError;
import com.tbf.xml.XmlValidator;

/**
 * FixedFile class.
 *
 */
public class FixedFile
	implements com.tbf.xml.XmlObject,
	com.tbf.xml.Validateable,
	java.io.Serializable {

	/**
	 * Constant for "record" node name.
	 */
	public static final String $RECORD = "record";

	/**
	 * Constant for "size" node name.
	 */
	public static final String $SIZE = "size";

	/**
	 * Constant for "type" node name.
	 */
	public static final String $TYPE = "type";

	/**
	 * Constant for "fixedFile" node name.
	 */
	public static final String $FIXED_FILE = "fixedFile";

	/**
	 * Constant for "fill" node name.
	 */
	public static final String $FILL = "fill";

	/**
	 * Constant for "provider" node name.
	 */
	public static final String $PROVIDER = "provider";


	/**
	 * Declarations for the XML related fields.
	 */
	protected java.util.ArrayList _Record = new java.util.ArrayList();
	protected String _Type = null;
	protected String _Provider = null;
	protected int _Size = -1;
	protected boolean _has_Size_ = false;
	protected String _Fill = null;


	/**
	 * Holds the parent object of this object.
	 */
	protected transient XmlObject _parent_ = null;


	/**
	 * Storage for UNEXPECTED_XML errors.
	 */
	protected transient java.util.Vector _unexpected_xml_errors_ = null;


	/**
	 * Default no args constructor.
	 */
	public FixedFile () {
	}


	/**
	 * Creates and populates an instance from the provided parse tree.
	 *
	 * @param  xml  the parse tree
	 */
	public FixedFile (XmlElement xml) {
		unmarshal(xml);
	}


	/**
	 * Creates and populates an instance from the provided parse tree.
	 *
	 * @param  xml  the parse tree
	 * @param  parent  the containibg XmlObject
	 */
	public FixedFile (XmlElement xml, XmlObject parent) {
		_parent_ = parent;
		unmarshal(xml);
	}


	/**
	 * Get the Record property.
	 */
	public java.util.ArrayList getRecord () {
		return (_Record);
	}


	public Record getRecordAt (int index)
			throws IndexOutOfBoundsException {
		return ((Record)_Record.get(index));
	}


	/**
	 * Get the count of elements in the Record property.
	 */
	public int getRecordCount () {
		if (_Record == null) {
			return (0);
		}

		return (_Record.size());
	}


	/**
	 * Set the Record property.
	 */
	public void setRecord (java.util.ArrayList newList) {

		if (newList == null) {
			_Record.clear();
		} else {
			_Record = (java.util.ArrayList)newList.clone();
		}
	}


	public void addRecord (Record obj) {
		if (obj == null) {
			return;
		}

		_Record.add(obj);
	}


	public void setRecordAt (Record obj, int index)
			throws IndexOutOfBoundsException {
		if (obj == null) {
			return;
		}

		_Record.set(index, obj);
	}


	public void removeRecord (Record obj) {
		if (obj == null) {
			return;
		}

		_Record.remove(obj);
	}


	public void removeRecordAt (int index)
			throws IndexOutOfBoundsException {
		_Record.remove(index);
	}


	private void setRecord (XmlElement xml) {

		_Record.clear();
		XmlElement saved_xml = xml;

		while (xml != null &&
			Record.matches(xml, this)) {
			Object obj = new Record(xml, this);
			_Record.add(obj);
			saved_xml.setLastProcessed(xml);
			xml = xml.next();
		}
	}


	/**
	 * Get the Type property.
	 */
	public String getType () {
		return (_Type);
	}


	/**
	 * Set the Type property.
	 */
	public void setType (String enumValue) {
		_Type = enumValue;
	}


	public void setType (com.tbf.util.EnumType new_value) {

		if (new_value == null) {
			_Type = null;
		} else {
			_Type = new_value.toString();
		}

	}


	/**
	 * Checks for whether Type is set or not.
	 *
	 * @return true if Type is set, false if not
	 */
	 public boolean hasType () {
		return (_Type != null);
	}


	/**
	 * Discards Type's value.
	 */
	 public void deleteType () {
		_Type = null;
	}


	/**
	 * Get the Provider property.
	 */
	public String getProvider () {
		return (_Provider);
	}


	/**
	 * Set the Provider property.
	 */
	public void setProvider (String enumValue) {
		_Provider = enumValue;
	}


	public void setProvider (com.tbf.util.EnumType new_value) {

		if (new_value == null) {
			_Provider = null;
		} else {
			_Provider = new_value.toString();
		}

	}


	/**
	 * Checks for whether Provider is set or not.
	 *
	 * @return true if Provider is set, false if not
	 */
	 public boolean hasProvider () {
		return (_Provider != null);
	}


	/**
	 * Discards Provider's value.
	 */
	 public void deleteProvider () {
		_Provider = null;
	}


	/**
	 * Get the Size property.
	 */
	public int getSize () {
		if (_has_Size_) {
			return (_Size);
		}

		return (-1);
	}


	/**
	 * Set the Size property.
	 */
	public void setSize (int new_value) {
		_Size = new_value;
		_has_Size_ = true;
		_format_errors.remove("FixedFile.Size");
	}


	public void setSize (String new_value) {

		if (new_value == null) {
			_Size = -1;
			_has_Size_ = false;
			return;
		}

		try {
			_Size = Integer.parseInt(new_value);
			_has_Size_ = true;
			_format_errors.remove("FixedFile.Size");
		} catch (NumberFormatException nfe) {
			_has_Size_ = false;
			XmlValidationError.addValidityFormatError(
				_format_errors, "FixedFile.Size", "Attribute",
				"fixedFile/size", new_value);
		}
	}


	/**
	 * Checks for whether Size is set or not.
	 *
	 * @return true if Size is set, false if not
	 */
	public boolean hasSize () {
		return (_has_Size_);
	}


	/**
	 * Discards Size's value.
	 */
	public void deleteSize () {
		_has_Size_ = false;
		_format_errors.remove("FixedFile.Size");
	}


	/**
	 * Get the Fill property.
	 */
	public String getFill () {
		return (_Fill);
	}


	/**
	 * Set the Fill property.
	 */
	public void setFill (String enumValue) {
		_Fill = enumValue;
	}


	public void setFill (com.tbf.util.EnumType new_value) {

		if (new_value == null) {
			_Fill = null;
		} else {
			_Fill = new_value.toString();
		}

	}


	/**
	 * Checks for whether Fill is set or not.
	 *
	 * @return true if Fill is set, false if not
	 */
	 public boolean hasFill () {
		return (_Fill != null);
	}


	/**
	 * Discards Fill's value.
	 */
	 public void deleteFill () {
		_Fill = null;
	}


	protected String _node_name_ = $FIXED_FILE;

	/**
	 * Get the XML tag name for this instance.
	 */
	public String getXmlTagName () {
		return (_node_name_);
	}


	/**
	 * Set the XML tag name for this instance.
	 */
	public void setXmlTagName (String node_name) {
		_node_name_ = node_name;
	}


	/**
	 * Gets the XML tag name for this class.
	 */
	public static String getClassXmlTagName () {
		return ($FIXED_FILE);
	}


	/**
	 * Keeps track of format errors that are
	 * thrown in the numeric setXXX() methods().
	 */
	protected java.util.Hashtable _format_errors =
		new java.util.Hashtable();


	/**
	 * This flag is used to used to check whether
	 * the validators have been created.
	 */
	transient protected static boolean _validators_created = false;

	/*
	 * XML Validators
	 */
	transient protected static XmlValidator 
		_Record_validator_ = null;
	transient protected static XmlValidator 
		_Type_validator_ = null;
	transient protected static XmlValidator 
		_Provider_validator_ = null;
	transient protected static XmlIntegerValidator
		_Size_validator_ = null;
	transient protected static XmlValidator 
		_Fill_validator_ = null;

	/**
	 * Create the validators for this class.
	 */
	protected static synchronized void createValidators () {

		if (_validators_created) {
			return;
		}

		_Record_validator_ = new XmlValidator(
			"FixedFile.Record", "Element", 
			"fixedFile/record", 0, -1);

		_Type_validator_ = new XmlValidator(
			"FixedFile.Type", "Attribute", 
			"fixedFile/type", 0, 1);

		_Provider_validator_ = new XmlValidator(
			"FixedFile.Provider", "Attribute", 
			"fixedFile/provider", 0, 1);

		_Size_validator_ = new XmlIntegerValidator(
			"FixedFile.Size", "Attribute",
			"fixedFile/size",
			0, XmlValidator.NOT_USED,
			0, XmlValidator.NOT_USED, 0, 1);

		_Fill_validator_ = new XmlValidator(
			"FixedFile.Fill", "Attribute", 
			"fixedFile/fill", 0, 1);

		_validators_created = true;
	}


	/**
	 * Checks this object to see if it will produce valid XML.
	 */
	public boolean isValid () {

		if (!(this instanceof Validateable)) {
			return (true);
		}

		java.util.Vector errors = getValidationErrors(true);
		if (errors == null || errors.size() < 1) {
			return (true);
		}

		return (false);
	}


	/**
	 * Checks each field on the object for validity and
	 * returns a Vector holding the validation errors.
	 */
	public java.util.Vector getValidationErrors () {
		return (getValidationErrors(false));
	}


	/**
	 * Checks each field on the object for validity and
	 * returns a java.util.Vector holding the validation errors.
	 *
	 * @return  a Vector containing the validation errors
	 */
	public java.util.Vector getValidationErrors (boolean return_on_error) {
		return (getValidationErrors(return_on_error, true));
	}


	/**
	 * Checks each field on the object for validity and
	 * returns a Vector holding the validation errors.
	 *
	 * @return  a Vector containing the validation errors
	 */
	public java.util.Vector getValidationErrors (
		boolean return_on_error, boolean traverse) {

		createValidators();

		java.util.Vector errors;
		if (_unexpected_xml_errors_ != null &&
				_unexpected_xml_errors_.size() > 0) {
			errors = (java.util.Vector)_unexpected_xml_errors_.clone();
			if (return_on_error) {
				return (errors);
			}
		} else {
			errors = new java.util.Vector(4, 4);
		}

		XmlValidationError e;
		e = _Type_validator_.validate(
			_Type, Type.class);
		if (e != null) {
			errors.addElement(e);
			if (return_on_error) {
				return (errors);
			}
		}

		e = _Provider_validator_.validate(
			_Provider, Provider.class);
		if (e != null) {
			errors.addElement(e);
			if (return_on_error) {
				return (errors);
			}
		}

		e = _Size_validator_.validate(
			_Size,
			_has_Size_, _format_errors);
		if (e != null) {
			errors.addElement(e);
			if (return_on_error) {
				return (errors);
			}
		}

		e = _Fill_validator_.validate(
			_Fill, Fill.class);
		if (e != null) {
			errors.addElement(e);
			if (return_on_error) {
				return (errors);
			}
		}


		if (!traverse) {
			if (errors.size() < 1) {
				return (null);
			}

			return (errors);
		}


		boolean is_valid;

		is_valid = _Record_validator_.isValid(
			_Record,
			errors, return_on_error, traverse);
		if (!is_valid && return_on_error) {
			return (errors);
		}



		if (errors.size() < 1) {
			return (null);
		}

		return (errors);
	}


	/**
	 * Checks the XML to see whether it matches the
	 * XML contents of this class.
	 */
	public static boolean matches (XmlElement xml, XmlObject parent) {

		if (xml == null) {
			return (false);
		}

		return (xml.matches($FIXED_FILE, nsm, parent));
	}


	/**
	 * This method unmarshals an XML document instance
	 * into an instance of this class.
	 */
	public static FixedFile unmarshal (
			InputStream in) throws Exception {

		FixedFile obj = new FixedFile();
		ObjectFactory.unmarshal(obj, in);
		return (obj);
	}


	/**
	 * Populates this object with the values from the 
	 * parsed XML.
	 * @deprecated  will be removed in a future release.
	 * Use {@link #unmarshal(XmlElement)}.
	 */
	public void fromXml (XmlElement xml) {
		unmarshal(xml);
	}


	/**
	 * Populates this object with the values from the 
	 * parsed XML.
	 *
	 * @since 2.5
	 */
	public void unmarshal (XmlElement xml) {

		if (xml == null) {
			return;
		}

		if (!xml.matches($FIXED_FILE, this)) {
			return;
		}

		java.util.Vector doc_namespaces = xml.getDeclaredNamespaces();
		if (doc_namespaces != null) {
			_doc_declared_namespaces_ = 
				(java.util.Vector)doc_namespaces.clone();
		}

		unmarshalAttributes(xml);

		/*
		 * Get the contained XmlElement, this is what we process
		 */
		xml = xml.getChildAt(0);
		if (xml == null) {
			return;
		}

		if (xml.matches($RECORD,
			Record.nsm, this)) {

			setRecord(xml);
			xml = xml.next();
			if (xml == null) {
				return;
			}
		}


		if (xml != null) {

			_unexpected_xml_errors_ =
				XmlValidationError.addUnexpectedXmlError(
					this, _unexpected_xml_errors_, xml);
		}
	}


	/**
	 * Unmarshal any attributes.
	 *
	 * @param xml the XmlElement holding the parsed XML
	 * @since 2.5
	 */
	protected void unmarshalAttributes (XmlElement xml) {

		/*
		 * Set the attribute based field(s)
		 */
		setType(xml.getAttribute($TYPE, this));
		setProvider(xml.getAttribute($PROVIDER, this));
		setSize(xml.getAttribute($SIZE, this));
		setFill(xml.getAttribute($FILL, this));
	}


	/**
	 * Writes this instance to a stream. 
	 *
	 * @param  stream  the OutputStream to write the XML object to
	 * @deprecated  This method will be removed in a future release.
	 * Use {@link #marshal(XmlOutputStream)} or {@link #marshal(OutputStream)}.
	 */
	public void toXml (OutputStream stream) {
		marshal(stream);
	}


	/**
	 * Writes this instance to a stream. 
	 *
	 * @param  stream  the OutputStream to write the XML object to
	 * @param  embed_files  set to true to embed files in the XML
	 * @deprecated  This method will be removed in a future release.
	 * Use {@link #marshal(XmlOutputStream)} or {@link #marshal(OutputStream)}.
	 */
	public void toXml (OutputStream stream, boolean embed_files) {

		XmlOutputStream out = new FormattedOutputStream(stream);
		out.setEmbedFiles(embed_files);
		marshal(out);
	}


	/**
	 * Writes this instance to a stream. 
	 *
	 * @param  stream  the OutputStream to write the XML object to
	 * @param  embed_files  set to true to embed files in the XML
	 * @deprecated  This method will be removed in a future release.
	 * Use {@link #marshal(XmlOutputStream)} or {@link #marshal(OutputStream)}.
	 */
	public void toXml (
			OutputStream stream, String indent, boolean embed_files)	{

		FormattedOutputStream out = new FormattedOutputStream(stream);
		out.setIndentString(indent);
		out.setEmbedFiles(embed_files);
		marshal(out);
	}


	/**
	 * Writes this instance to a stream. If the OutputStream is not an
	 * instance of XmlOutputStream then a FormattedOutputStream
	 * will be created which wraps the OutputStream.
	 *
	 * @param  stream  the OutputStream to write the XML object to
	 * @see #marshal(XmlOutputStream)
	 * @since 2.5
	 */
	public void marshal (OutputStream stream) {

		XmlOutputStream out = new FormattedOutputStream(stream);
		marshal(out);
	}


	/**
	 * Writes this instance to an XmlOutputStream.
	 *
	 * @param  out  the XmlOutputStream to write the XML object to
	 * @see #marshal(OutputStream)
	 * @since 2.5
	 */
	public void marshal (XmlOutputStream out) {

		XmlAttributeList attrs = new XmlAttributeList(nsm);
		attrs = marshalAttributes(attrs);
		out.pushScope();
		out.writeStartTag(getXmlTagName(), attrs, false);
		out.incrementIndent();

		out.write(null,
			getRecord());

		out.decrementIndent();
		out.writeEndTag(getXmlTagName());
		out.popScope();
	}


	/**
	 * Get the XmlAttributeList for marshalling.
	 *
	 * @param attrs  the currently populated XmlAttributeList.
	 * @return  a populated XmlAttributeList
	 * @since 2.5
	 */
	protected XmlAttributeList marshalAttributes (XmlAttributeList attrs) {

		if (attrs == null) {
			attrs = new XmlAttributeList();
		}

		attrs.add($TYPE, _Type);
		attrs.add($PROVIDER, _Provider);
		attrs.add($SIZE, _Size, _has_Size_);
		attrs.add($FILL, _Fill);

		return (attrs);
	}


	/**
	 * Get this object's parent object.
	 */
	public XmlObject get$Parent () {
		return (_parent_);
	}


	/**
	 * Set this object's parent object.
	 */
	public void set$Parent (XmlObject parent) {
		_parent_ = parent;
	}


	/**
	 * The default <code>XmlNamespaceManager</code> for this class.
	 * @since 2.5
	 */
	public static XmlNamespaceManager nsm = null;


	/**
	 * Get the <code>XmlNamespaceManager</code> for this class.
	 * This will be null if no namespaces on this class or if
	 * namespace support is disabled during code generation.
	 *
	 * @since 2.5
	 */
	public XmlNamespaceManager get$NamespaceManager () {
		return (nsm);
	}


	/**
	 * Storage for namespaces declared in the input document.
	 * @since 2.5
	 */
	protected java.util.Vector _doc_declared_namespaces_ = null;


	/**
	 * Get the Vector holding the namespaces declared in the element
	 * that this instance was unmarshalled from.
	 *
	 * @since 2.5
	 */
	public java.util.Vector get$DocumentNamespaces () {
		return (_doc_declared_namespaces_);
	}


	/**
	 * Enumeration types for the Type property.
	 */
	public static final class Type
			extends com.tbf.util.EnumType {

		public static final Type NAILBA800 = 
			new Type(0, "Nailba800");
		public static final Type OR01 = 
			new Type(1, "OR01");


		protected Type(int value, String desc) {
			super(value, desc);
		}


		public static final java.util.Enumeration elements () {
			return (elements(Type.class));
		}


		public static final Type fromString (String str) {
			return ((FixedFile.Type)
				getByString(FixedFile.Type.class, str));
		}
	}


	/**
	 * Enumeration types for the Provider property.
	 */
	public static final class Provider
			extends com.tbf.util.EnumType {

		public static final Provider EMSI = 
			new Provider(0, "EMSI");
		public static final Provider LAB_ONE = 
			new Provider(1, "LabOne");


		protected Provider(int value, String desc) {
			super(value, desc);
		}


		public static final java.util.Enumeration elements () {
			return (elements(Provider.class));
		}


		public static final Provider fromString (String str) {
			return ((FixedFile.Provider)
				getByString(FixedFile.Provider.class, str));
		}
	}


	/**
	 * Enumeration types for the Fill property.
	 */
	public static final class Fill
			extends com.tbf.util.EnumType {

		public static final Fill BLANK = 
			new Fill(0, "BLANK");


		protected Fill(int value, String desc) {
			super(value, desc);
		}


		public static final java.util.Enumeration elements () {
			return (elements(Fill.class));
		}


		public static final Fill fromString (String str) {
			return ((FixedFile.Fill)
				getByString(FixedFile.Fill.class, str));
		}
	}
}
