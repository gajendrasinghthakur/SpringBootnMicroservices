package com.csc.fsg.nba.correspondence;

/*
 * ************************************************************** <BR>
 * This program contains trade secrets and confidential information which<BR>
 * are proprietary to CSC Financial Services Groupï¿½.  The use,<BR>
 * reproduction, distribution or disclosure of this program, in whole or in<BR>
 * part, without the express written permission of CSC Financial Services<BR>
 * Group is prohibited.  This program is also an unpublished work protected<BR>
 * under the copyright laws of the United States of America and other<BR>
 * countries.  If this program becomes published, the following notice shall<BR>
 * apply:
 *     Property of Computer Sciences Corporation.<BR>
 *     Confidential. Not for publication.<BR>
 *     Copyright (c) 2002-2008 Computer Sciences Corporation. All Rights Reserved.<BR>
 * ************************************************************** <BR>
 */

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

import org.apache.soap.Constants;
import org.apache.soap.Fault;
import org.apache.soap.SOAPException;
import org.apache.soap.encoding.SOAPMappingRegistry;
import org.apache.soap.encoding.soapenc.StringDeserializer;
import org.apache.soap.rpc.Call;
import org.apache.soap.rpc.Parameter;
import org.apache.soap.rpc.Response;
import org.apache.soap.transport.http.SOAPHTTPConnection;
import org.apache.soap.util.xml.QName;

import com.csc.fsg.nba.correspondence.docprintschema.DocPrintForms;
import com.csc.fsg.nba.correspondence.docprintschema.DocPrintVariables;
import com.csc.fsg.nba.correspondence.docprintschema.Fields;
import com.csc.fsg.nba.correspondence.docprintschema.Forms;
import com.csc.fsg.nba.exception.NbaBaseException;
import com.csc.fsg.nba.foundation.NbaBase64;
import com.csc.fsg.nba.foundation.NbaUtils;
import com.csc.fsg.nba.vo.NbaCorrespondenceRequestVO;
import com.csc.fsg.nba.vo.NbaDst;
import com.csc.fsg.nba.vo.NbaTXLife;
import com.csc.fsg.nba.vo.NbaUserVO;
import com.csc.fsg.nba.vo.configuration.CorrMethod;

/** 
 * This class provides the correspondence adapter implementation for Document Solutions.
 * Basically it encapsulates all low level details involved while interacting with Document Systems.
 * <p>
 * <b>Modifications:</b><br>
 * <table border=0 cellspacing=5 cellpadding=5>
 * <thead>
 *  <th align=left>Project</th><th align=left>Release</th><th align=left>Description</th>
 * </thead>
 * <tr><td>NBA013</td><td>Version 2</td><td>Correspondence System</td></tr>
 * <tr><td>NBA027</td><td>Version 3</td><td>Performance Tuning</td></tr>
 * <tr><td>SPR1283</td><td>Version 3</td><td>Provide support for upgraded struts.jar</td></tr>
 * <tr><td>ACN012</td><td>Version 4</td><td>Architecture Changes</td></tr>
 * <tr><td>NBA129</td><td>Version 5</td><td>xPression correspondence</td></tr>
 * <tr><td>NBA146</td><td>Version 6</td><td>Workflow integration</td></tr>
 * <tr><td>NBA213</td><td>Version 7</td><td>Unfied user Interfacerofl</td></tr>
 * <tr><td>SPR3345</td><td>Version 7</td><td>Batch Print processing for Document Solutions correspondence was never coded.</td></tr>
 * <tr><td>SPR3329</td><td>Version 7</td><td>Prevent erroneous "Retrieve variable name is invalid" messages from being generated by OINK</td></tr>
 * </table>
 * <p>
 * @author CSC FSG Developer
 * @version 7.0.0
 * @since New Business Accelerator - Version 2
 */
public class NbaDocumentSolutionsAdapter extends NbaCorrespondenceAdapterBase {
	protected final static String DOC_SOL_HTML_REQUEST = "HTML";
	protected final static String DOC_SOL_PDF_REQUEST = "PDF";
	protected final static String DOC_SOL_CLEAR_REQUEST = "EXIT";
	protected final static String DOC_SOL_VARIABLES_REQUEST = "VAR";
	protected final static String DOC_SOL_LETTERS_REQUEST = "ALL";
	protected final static String DOC_SOL_WIP_REQUEST = "WIP";
	protected final static String DOC_SOL_VARIABLE_PREFIX = "D";

	//Constants to Indentify method types
	protected final static String MAIN_METHOD = "MAIN";
	protected final static String SUPPORT_METHOD = "SUPPORT";

	protected java.lang.String strExtrFileStream;
	protected java.lang.String strUniqueId;
	protected java.lang.String strXmlFileStream;
/**
 * This constructor should never be used outside the current package.
 */
protected NbaDocumentSolutionsAdapter() {
    super();
}
/**
 * This method creates the variable data for a letter  
 * @param strLetterName Name of the Letter which needs to be created
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs. 
 */
private void createExtrFileStream(String strLetterName) throws NbaBaseException {
	if (strLetterName == null || strLetterName.length() == 0) {
		strLetterName = getLetterNameFromSource();
	}

	Fields fields = null;
	try {
		strExtrFileStream = strLetterName; //Pass in the letter name for which variables need to be resolved
		fields = DocPrintVariables.unmarshal(new ByteArrayInputStream(invokeDocSolSupport(DOC_SOL_VARIABLES_REQUEST))).getImage().getFields();
	} catch (Exception e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException("Error in :" + this.getClass().getName(), e);
	}

	NbaDocumentSolutionsExtract extract = new NbaDocumentSolutionsExtract();

	initializeOinkAccess(getUser()); //Set the contract information necessary for onik to work on   NBA146

	boolean debugLogging = getLogger(this.getClass().getName()).isDebugEnabled(); // NBA027
	for (int i = 0; i < fields.getName().size(); i++) {
		String aVariable = fields.getName().get(i).toString();
		if (!aVariable.startsWith(DOC_SOL_VARIABLE_PREFIX)) {
			try { //handle invalid XML tag exceptions
				extract.setVariableValue(aVariable, resolveVariableValue(aVariable.substring(4)));
				if (debugLogging) { // NBA027
					getLogger(this.getClass().getName()).logDebug(aVariable + " : " + extract.getVariableValue(aVariable));
				} // NBA027
			} catch (NbaBaseException e) { //do not throw these exceptions
			    getLogger(this.getClass().getName()).logException(e); //SPR3329
			}
		}
	}

	//At this time the nbaDst always points to a CASE
	extract.setCompany(nbaDst.getNbaLob().getBackendSystem() + nbaDst.getNbaLob().getCompany());
	extract.setLetter(strLetterName);
	extract.setLob(nbaDst.getNbaLob().getPlan());
	extract.setPolicyNumber(nbaDst.getNbaLob().getPolicyNumber());
	strExtrFileStream = extract.marshal();
}
/**
 * This method frees up all resources used by the correspondence system.
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs.
 */
public void freeResources() throws NbaBaseException {
	invokeDocSolMain(DOC_SOL_CLEAR_REQUEST);
}
/**
 * This method returns the extract data used for Letter generation.
 * @return java.lang.String
 */
public String getExtract() {
    return strExtrFileStream;
}
/**
 * This method returns the Letter in HTML format, which basically represents a preview of the letter.
 * @return byte[]
 * @param strLetterName java.lang.String
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs.
 */
public byte[] getLetterAsHTML(String strLetterName) throws NbaBaseException {
	//create an extract if it is not created
	if (strExtrFileStream == null || strExtrFileStream.length() == 0) {
		createExtrFileStream(strLetterName);
	}
	return invokeDocSolMain(DOC_SOL_HTML_REQUEST);
}
/**
 * This method returns the Letter in PDF format. The PDF letter generation request requires
 * the name of the letter to be generated, and the variable XML of the changed letter contents 
 * @return byte[]
 * @param strLetterName Name of the letter to be gererated.
 * @param strChangedXml Change letter contents obtained from the HTML preview of the letter
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs. 
 */
public byte[] getLetterAsPDF(String strLetterName, String strChangedXml) throws NbaBaseException {
	strXmlFileStream = (strChangedXml == null ? "" : strChangedXml);
	//create an extract if it is not created
	if (strExtrFileStream == null || strExtrFileStream.length() == 0) {
		createExtrFileStream(strLetterName);
	}
	return invokeDocSolMain(DOC_SOL_PDF_REQUEST);
}
/**
 * This method retrieves a <code>List</code> of Correspondence applicable for
 * On demand Correspondence. Category name is not used by Document Solutions 
 * and will be null.
 * @return java.util.List
 * @exception com.csc.fsg.nba.exception.NbaBaseException This exception is thrown whenever there is an error in Document Solutions.
 */
public List getLetterNames(String categoryName) throws NbaBaseException {
    Forms forms = null;
    try {
        forms = DocPrintForms.unmarshal(new ByteArrayInputStream(invokeDocSolSupport(DOC_SOL_LETTERS_REQUEST))).getForms();
    } catch (Exception e) {
        throw new NbaBaseException("Error in :" + this.getClass().getName(), e);
    }
    List info = new ArrayList();
	//begin NBA129
    for (int i = 0; i < forms.getNameAndDescAndCategoryAndDefaultDataSourceNameCount(); i++) {
        if (forms.getNameAndDescAndCategoryAndDefaultDataSourceNameAt(i).getDesc().length() > 0) { //meaning that this is an ondemand letter
            String[] data = new String[4];
            data[0] = forms.getNameAndDescAndCategoryAndDefaultDataSourceNameAt(i).getName();
			data[1] = forms.getNameAndDescAndCategoryAndDefaultDataSourceNameAt(i).getDesc().substring(3); 
            data[2] = forms.getNameAndDescAndCategoryAndDefaultDataSourceNameAt(i).getDesc().substring(0, 1); //PREVIEW Flag
            data[3] = forms.getNameAndDescAndCategoryAndDefaultDataSourceNameAt(i).getDesc().substring(1, 2); //PDF Flag
            info.add(data);
        }
    }//end NBA129
    return info;
}
/**
 * This method retrieves a list of Categories. this is not a valid option for Document solutions
 * @return java.util.List
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs.
 */
//NBA129 new method
public List getCategoryNames() throws NbaBaseException {
	
	throw new NbaBaseException("Category request is invalid for " + this.getClass().getName());
}
/**
 * This method initializes all instance variables.
 * @param dst The NbaDst Xml representing the contract for whic a letter needs to be generated
 * @param user The user id and password of the user requesting correspondence
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs. 
 */
//NBA129, NBA213 changed method signature
public void initializeObjects(NbaDst dst, NbaUserVO user) throws NbaBaseException {
	initializeNbaDst(dst);
	setUser(user); // NBA146
	if (nbaDst.getNbaLob().getPolicyNumber() != null) { //The first preference is always policy number	
		strUniqueId = "POLNUM_" + nbaDst.getNbaLob().getPolicyNumber();
	} else {
		strUniqueId = "WORKID_" + nbaDst.getID();
	}
	
	strExtrFileStream = new String();
	strXmlFileStream = new String();
}
/**
 * This method forms the interaction point with Document Solutions using SOAP. It proccesses
 * requests to generate Letters iin PDF or HTML format.
 * @return byte[]
 * @param strRunType A string identifying the type of request (PDF, HTML or WIP)
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs. 
 */
protected byte[] invokeDocSolMain(String strRunType) throws NbaBaseException {
	byte[] decodeBytes = null;
	if (nbaDst == null || strUniqueId == null) {
		getLogger(this.getClass().getName()).logError("Objects not initialized!");
		throw new NbaBaseException("Objects not initialized!");
	}
	try {
		URL url = new URL(getConfigInfo().getWSDLURL()); //ACN012
		String encodingStyleURI = Constants.NS_URI_SOAP_ENC;
		CorrMethod aMethod = getCorrMethod(MAIN_METHOD); //ACN012

		// Build the call.
		Call call = new Call();
		//begin SPR1283
		SOAPMappingRegistry smr = new SOAPMappingRegistry();
		StringDeserializer sd = new StringDeserializer();
		smr.mapTypes(Constants.NS_URI_SOAP_ENC, new QName(null, "Result"), null, null, sd);
		smr.mapTypes(Constants.NS_URI_SOAP_ENC, new QName(null, "strMIMEType"), null, null, sd);		
		smr.mapTypes(Constants.NS_URI_SOAP_ENC, new QName(null, "strOutputStream"), null, null, sd);
		call.setSOAPMappingRegistry(smr);
		call.setSOAPTransport(new SOAPHTTPConnection());
		//end SPR1283			
		call.setTargetObjectURI(getConfigInfo().getTargetURI()); //ACN012
		call.setMethodName(aMethod.getName());
		call.setEncodingStyleURI(encodingStyleURI);

		Vector params = new Vector();
		params.addElement(new Parameter(aMethod.getParamAt(0).getName(), NbaUtils.classForName(aMethod.getParamAt(0).getDatatype()), strExtrFileStream, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(1).getName(), NbaUtils.classForName(aMethod.getParamAt(1).getDatatype()), strRunType, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(2).getName(), NbaUtils.classForName(aMethod.getParamAt(2).getDatatype()), strUniqueId, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(3).getName(), NbaUtils.classForName(aMethod.getParamAt(3).getDatatype()), strXmlFileStream, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(4).getName(), NbaUtils.classForName(aMethod.getParamAt(4).getDatatype()), "", null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(5).getName(), NbaUtils.classForName(aMethod.getParamAt(4).getDatatype()), new String(), null)); //ACN012

		call.setParams(params);
		Response resp = call.invoke(url, aMethod.getActionURI()); //ACN012

		if (resp.generatedFault()) {
			Fault fault = resp.getFault();
			getLogger(this.getClass().getName()).logError(getConfigInfo().getServiceProvider() + "call failed");
			throw new NbaBaseException(fault.getFaultString());
		} else {
			if (resp.getReturnValue().getValue().equals("0")) {
				Parameter output = (Parameter) resp.getParams().get(1); //0 is the MIME type, 1 is the data
				decodeBytes = NbaBase64.decode((String) output.getValue());
			} else {
				throw new NbaBaseException("Error while processing request in " + getConfigInfo().getServiceProvider());
			}
		}
	} catch (ClassNotFoundException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	} catch (IOException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	} catch (SOAPException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	}
	return decodeBytes;
}
/**
 * This method forms the interaction point with Document solutions using SOAP. It proccesses
 * requests to retrieve letter names & variables.
 * @return byte[]
 * @param strCommand A string identifying the type of request (ALL or VAR)
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs.  
 */
protected byte[] invokeDocSolSupport(String strCommand) throws NbaBaseException {
	byte[] outputBytes = null;
	if (nbaDst == null || strUniqueId == null) {
		getLogger(this.getClass().getName()).logError("Objects not initialized!");
		throw new NbaBaseException("Objects not initialized!");
	}
	try {
		URL url = new URL(getConfigInfo().getWSDLURL()); //ACN012
		String encodingStyleURI = Constants.NS_URI_SOAP_ENC;
		CorrMethod aMethod = getCorrMethod(SUPPORT_METHOD); //ACN012

		// Build the call.
		Call call = new Call();
		//begin SPR1283
		SOAPMappingRegistry smr = new SOAPMappingRegistry();
		StringDeserializer sd = new StringDeserializer();
		smr.mapTypes(Constants.NS_URI_SOAP_ENC, new QName(null, "Result"), null, null, sd);
		smr.mapTypes(Constants.NS_URI_SOAP_ENC, new QName(null, "strXmlFile"), null, null, sd);
		call.setSOAPMappingRegistry(smr);
		call.setSOAPTransport(new SOAPHTTPConnection());
		//end SPR1283		
		call.setTargetObjectURI(getConfigInfo().getTargetURI()); //ACN012
		call.setMethodName(aMethod.getName());
		call.setEncodingStyleURI(encodingStyleURI);

		Vector params = new Vector();
		params.addElement(new Parameter(aMethod.getParamAt(0).getName(), NbaUtils.classForName(aMethod.getParamAt(0).getDatatype()), strCommand, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(1).getName(), NbaUtils.classForName(aMethod.getParamAt(1).getDatatype()), "\"" + strExtrFileStream + "\"", null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(2).getName(), NbaUtils.classForName(aMethod.getParamAt(2).getDatatype()), strUniqueId, null)); //ACN012
		params.addElement(new Parameter(aMethod.getParamAt(3).getName(), NbaUtils.classForName(aMethod.getParamAt(4).getDatatype()), new String(), null)); //ACN012

		call.setParams(params);
		Response resp = call.invoke(url, aMethod.getActionURI()); //ACN012

		if (resp.generatedFault()) {
			Fault fault = resp.getFault();
			getLogger(this.getClass().getName()).logError(getConfigInfo().getServiceProvider() + "call failed");
			throw new NbaBaseException(fault.getFaultString());
		} else {
			if (resp.getReturnValue().getValue().equals("0")) {
				outputBytes = ((Parameter) resp.getParams().get(0)).getValue().toString().getBytes();
			} else {
				throw new NbaBaseException("Error while processing request in " + getConfigInfo().getServiceProvider());
			}
		}
	} catch (ClassNotFoundException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	} catch (IOException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	} catch (SOAPException e) {
		getLogger(this.getClass().getName()).logError(e);
		throw new NbaBaseException(e);
	}
	return outputBytes;
}
/**
 * This method marks the letter for batch printing.
 * @exception com.csc.fsg.nba.exception.NbaBaseException The exception description.
 */
public void markForBatchPrint() throws NbaBaseException {
	
    invokeDocSolMain(DOC_SOL_WIP_REQUEST); //SPR3345
	freeResources();
}
/**
 * This method can be used to provide the extract for the letter to be generated. 
 * @param extract An xml string representing the letter extract
 */
public void setExtract(String extract) {
	strExtrFileStream = extract;
}
/**
 * This method returns an extract for a specific letter. this is not a valid option for Document Solutions
 * @param strLetterName Letter name the extract is to be created for
 * @return String
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs.
 */
//NBA129
public String createExtract(String strLetterName) throws NbaBaseException {
	throw new NbaBaseException("Create extract is invalid for " + this.getClass().getName());
}

//APSL5200
public void initializeObjects(NbaCorrespondenceRequestVO correspondenceRequestVO) throws NbaBaseException {
	// TODO Auto-generated method stub
	throw new NbaBaseException("Initialize Objects is invalid for " + this.getClass().getName());
}

/**
 * This method initializes all instance variables.
 * @param dst The NbaDst Xml representing the contract for whic a letter needs to be generated
 * @param user The user id and password of the user requesting correspondence
 * @param nbaTxLife gets the TxLife
 * @exception com.csc.fsg.nba.exception.NbaBaseException Throw this exception whenever an error occurs. 
 */
//NBLXA-2114 new Method
public void initializeObjects(NbaDst dst, NbaUserVO user, NbaTXLife nbaTxLife) throws NbaBaseException {
		// TODO Auto-generated method stub

	}
}
